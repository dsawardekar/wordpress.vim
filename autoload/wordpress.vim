"
" This file was automatically generated by riml 0.4.0.tek
" Modify with care!
"
function! s:SID()
  if exists('s:SID_VALUE')
    return s:SID_VALUE
  endif
  let s:SID_VALUE = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
  return s:SID_VALUE
endfunction

if exists('g:wordpress_vim_loaded')
  finish
endif
" included: 'app.riml'
" included: 'msg.riml'
function! s:echo_warn(...)
  call s:echo_with(a:000, 'WarningMsg')
endfunction

function! s:echo_error(...)
  call s:echo_with(a:000, 'ErrorMsg')
endfunction

function! s:echo_msg(...)
  if exists('g:speckle_mode')
    let logger = s:get_logger()
    let res = call(logger['info'], a:000, logger)
  else
    call s:echo_with(a:000, 'None')
  endif
endfunction

function! s:echo_with(args, style)
  if exists('g:speckle_mode')
    return
  endif
  let msg = join(a:args, ' ')
  execute ":echohl " . a:style
  echomsg msg
  echohl None
endfunction

" included: 'controller.riml'
" included: 'with_dir.riml'
" included: 'delegate.riml'
function! s:DelegateConstructor(scope, method)
  let delegateObj = {}
  let delegateObj.scope = a:scope
  let delegateObj.method = a:method
  let delegateObj.id = s:next_delegate_id()
  let delegateObj.unlinked = 0
  let delegateObj.invoke = function('<SNR>' . s:SID() . '_Delegate_invoke')
  let delegateObj.unlink = function('<SNR>' . s:SID() . '_Delegate_unlink')
  return delegateObj
endfunction

function! s:Delegate_invoke(...) dict
  if self.unlinked
    return
  endif
  return call(self.scope[self.method], a:000, self.scope)
endfunction

function! s:Delegate_unlink() dict
  let self.unlinked = 1
endfunction

let s:delegate_id_counter = 0
let s:delegate_instances = {}
function! s:next_delegate_id()
  let s:delegate_id_counter += 1
  return s:delegate_id_counter
endfunction

function! s:create_delegate(scope, method)
  let delegate = s:DelegateConstructor(a:scope, a:method)
  let id = delegate.id
  let s:delegate_instances[id] = delegate
  let delegate_name = "s:DelegateFunction" . id
  let delegate_func = "function! " . delegate_name . "(...)\n  let id = " . id . "\n  let NewDelegate = s:get_delegate_instance(id)\n  return call(NewDelegate.invoke, a:000, NewDelegate)\nendfunction"
  execute delegate_func
  let DelegateFuncRef = function(delegate_name)
  return DelegateFuncRef
endfunction

function! s:get_delegate_instance(id)
  return s:delegate_instances[a:id]
endfunction

function! s:remove_delegate(Func)
  let func_name = s:get_delegate_name(a:Func)
  let id = substitute(func_name, '\v^(.*)(DelegateFunction)(\d+).*', '\3', '')
  execute ":unlet s:delegate_instances[" . id . "]"
  execute ":delfunction " . func_name
endfunction

function! s:unlink_delegate(Func)
  let func_name = s:get_delegate_name(a:Func)
  let id = substitute(func_name, '\v^(.*)(DelegateFunction)(\d+).*', '\3', '')
  let delegate = s:get_delegate_instance(id)
  call delegate.unlink()
endfunction

function! s:get_delegate_name(Func)
  let func_def = string(a:Func)
  let sid = s:SID()
  let pattern = "\\v^function.{1}'(.*)'.{1}$"
  let result = substitute(func_def, pattern, '\1', '')
  let result = substitute(result, 's:', '<SNR>' . sid . '_', '')
  return result
endfunction

function! s:new_delegate(scope, method)
  return s:get_delegate_name(s:create_delegate(a:scope, a:method))
endfunction

function! s:WithDirConstructor(...)
  let __splat_var_cpy = copy(a:000)
  if !empty(__splat_var_cpy)
    let dir = remove(__splat_var_cpy, 0)
  else
    let dir = ''
  endif
  let withDirObj = {}
  let withDirObj.dir = dir
  let withDirObj.trap_errors = 1
  let withDirObj.set_dir = function('<SNR>' . s:SID() . '_WithDir_set_dir')
  let withDirObj.get_dir = function('<SNR>' . s:SID() . '_WithDir_get_dir')
  let withDirObj.get_trap_errors = function('<SNR>' . s:SID() . '_WithDir_get_trap_errors')
  let withDirObj.set_trap_errors = function('<SNR>' . s:SID() . '_WithDir_set_trap_errors')
  let withDirObj.run = function('<SNR>' . s:SID() . '_WithDir_run')
  return withDirObj
endfunction

function! s:WithDir_set_dir(dir) dict
  let self.dir = a:dir
endfunction

function! s:WithDir_get_dir() dict
  return self.dir
endfunction

function! s:WithDir_get_trap_errors() dict
  return self.trap_errors
endfunction

function! s:WithDir_set_trap_errors(trap_errors) dict
  let self.trap_errors = a:trap_errors
endfunction

function! s:WithDir_run(scope, method, args) dict
  let orig_dir = getcwd()
  if haslocaldir()
    let chdir_cmd = 'lcd'
  else
    let chdir_cmd = 'cd'
  endif
  execute ":" . chdir_cmd . " " . self.get_dir()
  if self.trap_errors
    try
      let result = call(a:scope[a:method], a:args, a:scope)
    catch
      let result = 0
    finally
      execute chdir_cmd . " " . orig_dir
    endtry
  else
    let result = call(a:scope[a:method], a:args, a:scope)
  endif
  return result
endfunction

" included: 'file_opener.riml'
function! s:FileOpenerConstructor()
  let fileOpenerObj = {}
  let fileOpenerObj.is_file_opener = 1
  let fileOpenerObj.mkdir_mode = 1
  let fileOpenerObj.exec_mode = 1
  let fileOpenerObj.exec_cmd = ''
  let fileOpenerObj.exec_mkdir = ''
  let fileOpenerObj.set_mkdir_mode = function('<SNR>' . s:SID() . '_FileOpener_set_mkdir_mode')
  let fileOpenerObj.get_mkdir_mode = function('<SNR>' . s:SID() . '_FileOpener_get_mkdir_mode')
  let fileOpenerObj.set_exec_mode = function('<SNR>' . s:SID() . '_FileOpener_set_exec_mode')
  let fileOpenerObj.get_exec_mode = function('<SNR>' . s:SID() . '_FileOpener_get_exec_mode')
  let fileOpenerObj.open = function('<SNR>' . s:SID() . '_FileOpener_open')
  let fileOpenerObj.open_with = function('<SNR>' . s:SID() . '_FileOpener_open_with')
  let fileOpenerObj.mkdir = function('<SNR>' . s:SID() . '_FileOpener_mkdir')
  let fileOpenerObj.build_cmd = function('<SNR>' . s:SID() . '_FileOpener_build_cmd')
  return fileOpenerObj
endfunction

function! s:FileOpener_set_mkdir_mode(mkdir_mode) dict
  let self.mkdir_mode = a:mkdir_mode
endfunction

function! s:FileOpener_get_mkdir_mode() dict
  return self.mkdir_mode
endfunction

function! s:FileOpener_set_exec_mode(exec_mode) dict
  let self.exec_mode = a:exec_mode
endfunction

function! s:FileOpener_get_exec_mode() dict
  return self.exec_mode
endfunction

function! s:FileOpener_open(file, mode) dict
  let cmd = self.build_cmd(a:file, a:mode)
  call self.mkdir(a:file)
  call self.open_with(cmd)
endfunction

function! s:FileOpener_open_with(cmd) dict
  if self.exec_mode
    execute a:cmd
  else
    let self.exec_cmd = a:cmd
  endif
endfunction

function! s:FileOpener_mkdir(file) dict
  let parent_dir = fnamemodify(a:file, ':p:h')
  if !isdirectory(parent_dir) && self.mkdir_mode
    if self.exec_mode
      if exists('*mkdir')
        call mkdir(parent_dir, 'p')
      endif
    else
      let self.exec_mkdir = parent_dir
    endif
  endif
endfunction

function! s:FileOpener_build_cmd(file, mode) dict
  let cmd = ''
  if a:mode ==# 'e' || a:mode ==# 'edit'
    let cmd = 'edit'
  elseif a:mode ==# 's' || a:mode ==# 'h' || a:mode ==# 'split'
    let cmd = 'split'
  elseif a:mode ==# 'v' || a:mode ==# 'vsplit'
    let cmd = 'vsplit'
  elseif a:mode ==# 't' || a:mode ==# 'tab'
    let cmd = 'tabedit'
  elseif a:mode ==# 'd' || a:mode ==# 'read'
    let cmd = 'read'
  elseif a:mode ==# 'abo' || a:mode ==# 'aboveleft' || a:mode ==# 'lefta' || a:mode ==# 'leftabove'
    let cmd = 'leftabove'
  elseif a:mode ==# 'rightb' || a:mode ==# 'rightbelow' || a:mode ==# 'bel' || a:mode ==# 'belowright'
    let cmd = 'rightbelow'
  elseif a:mode ==# 'to' || a:mode ==# 'topleft'
    let cmd = 'topleft'
  elseif a:mode ==# 'bo' || a:mode ==# 'botright'
    let cmd = 'botright'
  else
    let cmd = 'edit'
  endif
  let cmd = ":" . cmd . " " . a:file
  return cmd
endfunction

" included: 'tags_option.riml'
function! s:TagsOptionConstructor()
  let tagsOptionObj = {}
  let tagsOptionObj.is_tags_option = 1
  let tagsOptionObj.append = function('<SNR>' . s:SID() . '_TagsOption_append')
  let tagsOptionObj.prepend = function('<SNR>' . s:SID() . '_TagsOption_prepend')
  let tagsOptionObj.get_tags = function('<SNR>' . s:SID() . '_TagsOption_get_tags')
  let tagsOptionObj.set_tags = function('<SNR>' . s:SID() . '_TagsOption_set_tags')
  let tagsOptionObj.to_list = function('<SNR>' . s:SID() . '_TagsOption_to_list')
  let tagsOptionObj.to_value = function('<SNR>' . s:SID() . '_TagsOption_to_value')
  return tagsOptionObj
endfunction

function! s:TagsOption_append(path) dict
  let tags = self.to_list(self.get_tags())
  call add(tags, a:path)
  let value = self.to_value(tags)
  call self.set_tags(value)
endfunction

function! s:TagsOption_prepend(path) dict
  let tags = self.to_list(self.get_tags())
  call insert(tags, a:path, 0)
  let value = self.to_value(tags)
  call self.set_tags(value)
endfunction

function! s:TagsOption_get_tags() dict
  return &tags
endfunction

function! s:TagsOption_set_tags(tags) dict
  execute ":setlocal tags=" . a:tags
endfunction

function! s:TagsOption_to_list(value) dict
  return split(a:value, ',')
endfunction

function! s:TagsOption_to_value(items) dict
  return join(a:items, ',')
endfunction

" included: 'choice_prompter.riml'
function! s:ChoicePrompterConstructor()
  let choicePrompterObj = {}
  let choicePrompterObj.prompt_for = function('<SNR>' . s:SID() . '_ChoicePrompter_prompt_for')
  let choicePrompterObj.get_input = function('<SNR>' . s:SID() . '_ChoicePrompter_get_input')
  let choicePrompterObj.validate = function('<SNR>' . s:SID() . '_ChoicePrompter_validate')
  return choicePrompterObj
endfunction

function! s:ChoicePrompter_prompt_for(choices) dict
  let index = 1
  let total = len(a:choices)
  for choice in a:choices
    call s:echo_msg(index . ". " . choice)
    let index = index + 1
  endfor
  let prompt = "Enter Choice (1-" . total . ") [q to quit]: "
  return self.get_input(prompt, total)
endfunction

function! s:ChoicePrompter_get_input(prompt, total_choices) dict
  let user_input = input(a:prompt)
  if user_input ==# 'q' || empty(user_input)
    return -1
  endif
  let parsed_input = self.validate(user_input, a:total_choices)
  if parsed_input ==# 0
    call s:echo_msg("Invalid Choice: " . user_input)
    return self.get_input(a:prompt, a:total_choices)
  endif
  return parsed_input
endfunction

function! s:ChoicePrompter_validate(text, total_choices) dict
  for valid_input in range(1, a:total_choices)
    if a:text ==# valid_input
      return valid_input
    endif
  endfor
  return 0
endfunction

" included: 'wpseek_api.riml'
function! s:WpSeekApiConstructor()
  let wpSeekApiObj = {}
  let wpSeekApiObj.api_loaded = 0
  let wpSeekApiObj.find_similar = function('<SNR>' . s:SID() . '_WpSeekApi_find_similar')
  let wpSeekApiObj.find_topics = function('<SNR>' . s:SID() . '_WpSeekApi_find_topics')
  let wpSeekApiObj.is_false = function('<SNR>' . s:SID() . '_WpSeekApi_is_false')
  let wpSeekApiObj.to_query = function('<SNR>' . s:SID() . '_WpSeekApi_to_query')
  let wpSeekApiObj.to_function_names = function('<SNR>' . s:SID() . '_WpSeekApi_to_function_names')
  let wpSeekApiObj.get_result_items = function('<SNR>' . s:SID() . '_WpSeekApi_get_result_items')
  let wpSeekApiObj.invoke = function('<SNR>' . s:SID() . '_WpSeekApi_invoke')
  let wpSeekApiObj.has_python = function('<SNR>' . s:SID() . '_WpSeekApi_has_python')
  let wpSeekApiObj.load_api = function('<SNR>' . s:SID() . '_WpSeekApi_load_api')
  let wpSeekApiObj.loaded = function('<SNR>' . s:SID() . '_WpSeekApi_loaded')
  let wpSeekApiObj.get_api_path = function('<SNR>' . s:SID() . '_WpSeekApi_get_api_path')
  return wpSeekApiObj
endfunction

function! s:WpSeekApi_find_similar(keyword, limit) dict
  let result = self.invoke('find_similar', a:keyword, a:limit)
  if self.is_false(result)
    return 0
  endif
  let items = self.get_result_items(result)
  let function_names = self.to_function_names(a:keyword, items)
  return function_names
endfunction

function! s:WpSeekApi_find_topics(keyword, limit) dict
  let result = self.invoke('find_topics', a:keyword, a:limit)
  if self.is_false(result)
    return 0
  endif
  return self.get_result_items(result)
endfunction

function! s:WpSeekApi_is_false(result) dict
  return type(a:result) ==# type(0) && a:result ==# 0
endfunction

function! s:WpSeekApi_to_query(keyword) dict
  return substitute(a:keyword, "'", "\\'", 'g')
endfunction

function! s:WpSeekApi_to_function_names(keyword, items) dict
  let function_names = []
  for item in a:items
    if item.name !=# a:keyword
      call add(function_names, item.name)
    endif
  endfor
  return function_names
endfunction

function! s:WpSeekApi_get_result_items(result) dict
  if has_key(a:result, 'items')
    let items = a:result.items
  else
    let items = []
  endif
  return items
endfunction

function! s:WpSeekApi_invoke(method, keyword, limit) dict
  call self.load_api()
  if !(self.has_python())
    call s:echo_error("Error: Vim with Python support is required.")
    return 0
  endif
  try
    execute ":python wpseek_api." . a:method . "('" . self.to_query(a:keyword) . "', " . a:limit . ")"
  catch
    call s:echo_error("Call to WpSeek API failed for: " . a:method)
    let api_result = 0
  endtry
  return api_result
endfunction

function! s:WpSeekApi_has_python() dict
  if has_key(self, 'mock_python')
    return self.mock_python
  endif
  return has('python')
endfunction

function! s:WpSeekApi_load_api() dict
  if self.api_loaded
    return 0
  endif
  execute ":python import sys"
  execute ":python sys.path.append('" . self.get_api_path() . "')"
  execute ":python from wpseek import WpSeekApi"
  execute ":python wpseek_api = WpSeekApi()"
  let self.api_loaded = 1
  return 1
endfunction

function! s:WpSeekApi_loaded() dict
  return self.api_loaded
endfunction

function! s:WpSeekApi_get_api_path() dict
  return g:wordpress_vim_path . "/lib/wpseek"
endfunction

" included: 'hook_match.riml'
function! s:HookMatchConstructor(...)
  let __splat_var_cpy = copy(a:000)
  if !empty(__splat_var_cpy)
    let keyword = remove(__splat_var_cpy, 0)
  else
    let keyword = ''
  endif
  let hookMatchObj = {}
  let hookMatchObj.keyword = keyword
  let hookMatchObj.kind = ''
  let hookMatchObj.is_hook_match = 1
  let hookMatchObj.set_keyword = function('<SNR>' . s:SID() . '_HookMatch_set_keyword')
  let hookMatchObj.set_kind = function('<SNR>' . s:SID() . '_HookMatch_set_kind')
  let hookMatchObj.get_kind = function('<SNR>' . s:SID() . '_HookMatch_get_kind')
  let hookMatchObj.get_keyword = function('<SNR>' . s:SID() . '_HookMatch_get_keyword')
  let hookMatchObj.is_match = function('<SNR>' . s:SID() . '_HookMatch_is_match')
  return hookMatchObj
endfunction

function! s:HookMatch_set_keyword(keyword) dict
  let self.keyword = a:keyword
endfunction

function! s:HookMatch_set_kind(kind) dict
  let self.kind = a:kind
endfunction

function! s:HookMatch_get_kind() dict
  return self.kind
endfunction

function! s:HookMatch_get_keyword() dict
  return self.keyword
endfunction

function! s:HookMatch_is_match() dict
  return has_key(self, 'kind') && self.kind !=# ''
endfunction

" included: 'hook_matcher.riml'
function! s:HookMatcherConstructor()
  let hookMatcherObj = {}
  let hookMatcherObj.lookup = function('<SNR>' . s:SID() . '_HookMatcher_lookup')
  let hookMatcherObj.match = function('<SNR>' . s:SID() . '_HookMatcher_match')
  let hookMatcherObj.is_kind_line = function('<SNR>' . s:SID() . '_HookMatcher_is_kind_line')
  let hookMatcherObj.is_word_line = function('<SNR>' . s:SID() . '_HookMatcher_is_word_line')
  let hookMatcherObj.get_kind_pattern = function('<SNR>' . s:SID() . '_HookMatcher_get_kind_pattern')
  let hookMatcherObj.get_word_pattern = function('<SNR>' . s:SID() . '_HookMatcher_get_word_pattern')
  let hookMatcherObj.get_kinds = function('<SNR>' . s:SID() . '_HookMatcher_get_kinds')
  return hookMatcherObj
endfunction

function! s:HookMatcher_lookup(key) dict
  return self.container.lookup(a:key)
endfunction

function! s:HookMatcher_match(line, current_word) dict
  let kinds = self.get_kinds()
  let result = self.lookup('hook_match')
  call result.set_keyword(a:current_word)
  for kind in kinds
    let method = kind.method
    if self.is_kind_line(a:line, method) && self.is_word_line(a:line, method, a:current_word)
      call result.set_kind(kind.name)
    endif
  endfor
  return result
endfunction

function! s:HookMatcher_is_kind_line(line, method) dict
  let kind_pattern = self.get_kind_pattern(a:method)
  return match(a:line, kind_pattern) !=# -1
endfunction

function! s:HookMatcher_is_word_line(line, method, word) dict
  let word_pattern = self.get_word_pattern(a:method, a:word)
  return match(a:line, word_pattern) !=# -1
endfunction

function! s:HookMatcher_get_kind_pattern(method) dict
  return '\v\s*.*' . a:method
endfunction

function! s:HookMatcher_get_word_pattern(method, word) dict
  let pattern = self.get_kind_pattern(a:method)
  let pattern .= '.*\(\s*[' . "'" . '"]'
  let pattern .= a:word
  return pattern
endfunction

function! s:HookMatcher_get_kinds() dict
  let kinds = []
  call add(kinds, {'name': 'action', 'method': 'do_action'})
  call add(kinds, {'name': 'alistener', 'method': 'add_action'})
  call add(kinds, {'name': 'filter', 'method': 'apply_filters'})
  call add(kinds, {'name': 'flistener', 'method': 'add_filter'})
  return kinds
endfunction

" included: 'readme_validator.riml'
function! s:ReadmeValidatorConstructor()
  let readmeValidatorObj = {}
  let readmeValidatorObj.api_loaded = 0
  let readmeValidatorObj.validate = function('<SNR>' . s:SID() . '_ReadmeValidator_validate')
  let readmeValidatorObj.has_python = function('<SNR>' . s:SID() . '_ReadmeValidator_has_python')
  let readmeValidatorObj.load_api = function('<SNR>' . s:SID() . '_ReadmeValidator_load_api')
  let readmeValidatorObj.loaded = function('<SNR>' . s:SID() . '_ReadmeValidator_loaded')
  let readmeValidatorObj.get_api_path = function('<SNR>' . s:SID() . '_ReadmeValidator_get_api_path')
  return readmeValidatorObj
endfunction

function! s:ReadmeValidator_validate(path) dict
  call self.load_api()
  if !(self.has_python())
    call s:echo_error("Error: Vim with Python support is required.")
    return 0
  endif
  try
    execute ":python readme_validator.validate('" . a:path . "')"
    let result = s:ReadmeValidationResultConstructor(readme_validation_status, readme_validation_result)
  catch
    call s:echo_error("Failed to Validate Readme")
    let result = {'is_readme_validation_result': 0}
  endtry
  return result
endfunction

function! s:ReadmeValidator_has_python() dict
  if has_key(self, 'mock_python')
    return self.mock_python
  endif
  return has('python')
endfunction

function! s:ReadmeValidator_load_api() dict
  if self.api_loaded
    return 0
  endif
  execute ":python import sys"
  execute ":python sys.path.append('" . self.get_api_path() . "')"
  execute ":python from readme_validator import ReadmeValidator"
  execute ":python readme_validator = ReadmeValidator()"
  let self.api_loaded = 1
  return 1
endfunction

function! s:ReadmeValidator_loaded() dict
  return self.api_loaded
endfunction

function! s:ReadmeValidator_get_api_path() dict
  return g:wordpress_vim_path . "/lib/wporg"
endfunction

function! s:ReadmeValidationResultConstructor(status, value)
  let readmeValidationResultObj = {}
  let readmeValidationResultObj.is_readme_validation_result = 1
  let readmeValidationResultObj.status = a:status
  let readmeValidationResultObj.value = a:value
  return readmeValidationResultObj
endfunction

" included: 'buffer_collection.riml'
" included: 'buffer.riml'
" included: 'buffer_type_detector.riml'
function! s:BufferTypeDetectorConstructor()
  let bufferTypeDetectorObj = {}
  let bufferTypeDetectorObj.get_project_path = function('<SNR>' . s:SID() . '_BufferTypeDetector_get_project_path')
  let bufferTypeDetectorObj.get_parent_path = function('<SNR>' . s:SID() . '_BufferTypeDetector_get_parent_path')
  let bufferTypeDetectorObj.is_core_path = function('<SNR>' . s:SID() . '_BufferTypeDetector_is_core_path')
  return bufferTypeDetectorObj
endfunction

function! s:BufferTypeDetector_get_project_path(path) dict
  let parent_path = self.get_parent_path(a:path)
  if self.is_core_path(parent_path)
    return parent_path
  else
    return a:path
  endif
endfunction

function! s:BufferTypeDetector_get_parent_path(path) dict
  let dirname = fnamemodify(a:path, ':t')
  if dirname ==# 'plugins' || dirname ==# 'mu-plugins'
    let parent_upto = ':h:h'
  else
    let parent_upto = ':h:h:h'
  endif
  return fnamemodify(a:path, parent_upto)
endfunction

function! s:BufferTypeDetector_is_core_path(path) dict
  let wp_load_path = a:path . "/wp-load.php"
  return filereadable(wp_load_path)
endfunction

" included: 'core_detector.riml'
function! s:CoreDetectorConstructor()
  let coreDetectorObj = {}
  let bufferTypeDetectorObj = s:BufferTypeDetectorConstructor()
  call extend(coreDetectorObj, bufferTypeDetectorObj)
  let coreDetectorObj.detect = function('<SNR>' . s:SID() . '_CoreDetector_detect')
  let coreDetectorObj.get_type = function('<SNR>' . s:SID() . '_CoreDetector_get_type')
  return coreDetectorObj
endfunction

function! s:CoreDetector_detect(path) dict
  let found = findfile('wp-load.php', a:path . ";")
  let result = {}
  if found !=# ''
    let result.status = 1
    let result.path = fnamemodify(found, ':h')
  else
    let result.status = 0
    let result.path = ''
  endif
  return result
endfunction

function! s:CoreDetector_get_type() dict
  return 'core'
endfunction

" included: 'wpcli_detector.riml'
function! s:WpCliDetectorConstructor()
  let wpCliDetectorObj = {}
  let bufferTypeDetectorObj = s:BufferTypeDetectorConstructor()
  call extend(wpCliDetectorObj, bufferTypeDetectorObj)
  let wpCliDetectorObj.detect = function('<SNR>' . s:SID() . '_WpCliDetector_detect')
  let wpCliDetectorObj.get_wp_cli_configs = function('<SNR>' . s:SID() . '_WpCliDetector_get_wp_cli_configs')
  let wpCliDetectorObj.has_wp_cli = function('<SNR>' . s:SID() . '_WpCliDetector_has_wp_cli')
  let wpCliDetectorObj.get_type = function('<SNR>' . s:SID() . '_WpCliDetector_get_type')
  return wpCliDetectorObj
endfunction

function! s:WpCliDetector_detect(path) dict
  let configs = self.get_wp_cli_configs()
  let result = {}
  let result.status = 0
  let result.path = ''
  for config in configs
    let found = self.has_wp_cli(config, a:path)
    if found !=# ''
      let result.status = 1
      let result.path = fnamemodify(found, ':h')
      break
    endif
  endfor
  return result
endfunction

function! s:WpCliDetector_get_wp_cli_configs() dict
  return ['wp-cli.local.yml', 'wp-cli.yml']
endfunction

function! s:WpCliDetector_has_wp_cli(config, path) dict
  return findfile(a:config, a:path . ";")
endfunction

function! s:WpCliDetector_get_type() dict
  return 'wpcli'
endfunction

" included: 'plugin_detector.riml'
function! s:PluginDetectorConstructor()
  let pluginDetectorObj = {}
  let bufferTypeDetectorObj = s:BufferTypeDetectorConstructor()
  call extend(pluginDetectorObj, bufferTypeDetectorObj)
  let pluginDetectorObj.detect = function('<SNR>' . s:SID() . '_PluginDetector_detect')
  let pluginDetectorObj.is_plugin = function('<SNR>' . s:SID() . '_PluginDetector_is_plugin')
  let pluginDetectorObj.has_plugin_file = function('<SNR>' . s:SID() . '_PluginDetector_has_plugin_file')
  let pluginDetectorObj.has_plugin_header = function('<SNR>' . s:SID() . '_PluginDetector_has_plugin_header')
  let pluginDetectorObj.get_type = function('<SNR>' . s:SID() . '_PluginDetector_get_type')
  return pluginDetectorObj
endfunction

function! s:PluginDetector_detect(path) dict
  let parent = fnamemodify(a:path, ':p')
  let has_parent = 1
  let result = {}
  let result.status = 0
  let result.path = ''
  while has_parent
    if self.is_plugin(parent)
      let result.status = 1
      let result.path = self.get_project_path(parent)
      break
    endif
    let new_parent = fnamemodify(parent, ':h')
    let has_parent = new_parent !=# parent
    let parent = new_parent
  endwhile
  return result
endfunction

function! s:PluginDetector_is_plugin(path) dict
  let dirname = fnamemodify(a:path, ':t')
  if dirname ==# 'plugins' || dirname ==# 'mu-plugins'
    return 1
  elseif dirname =~# 'repo'
    let parent_dir = fnamemodify(a:path, ':h')
    let parent_dirname = fnamemodify(parent_dir, ':t')
    let plugin_file = parent_dir . "/" . dirname . "/" . parent_dirname . ".php"
    return self.has_plugin_file(plugin_file) && self.has_plugin_header(plugin_file)
  else
    let plugin_file = a:path . "/" . dirname . ".php"
    return self.has_plugin_file(plugin_file) && self.has_plugin_header(plugin_file)
  endif
endfunction

function! s:PluginDetector_has_plugin_file(file) dict
  return filereadable(a:file)
endfunction

function! s:PluginDetector_has_plugin_header(file) dict
  let lines = readfile(a:file)
  for line in lines
    if line =~# '^\s*Plugin Name:'
      return 1
    endif
  endfor
  return 0
endfunction

function! s:PluginDetector_get_type() dict
  return 'plugin'
endfunction

" included: 'theme_detector.riml'
function! s:ThemeDetectorConstructor()
  let themeDetectorObj = {}
  let bufferTypeDetectorObj = s:BufferTypeDetectorConstructor()
  call extend(themeDetectorObj, bufferTypeDetectorObj)
  let themeDetectorObj.detect = function('<SNR>' . s:SID() . '_ThemeDetector_detect')
  let themeDetectorObj.get_wp_path = function('<SNR>' . s:SID() . '_ThemeDetector_get_wp_path')
  let themeDetectorObj.has_theme_header = function('<SNR>' . s:SID() . '_ThemeDetector_has_theme_header')
  let themeDetectorObj.get_type = function('<SNR>' . s:SID() . '_ThemeDetector_get_type')
  return themeDetectorObj
endfunction

function! s:ThemeDetector_detect(path) dict
  let found = findfile('style.css', a:path . ";")
  let result = {}
  if found !=# '' && self.has_theme_header(found)
    let result.status = 1
    let result.path = self.get_wp_path(found)
  else
    let result.status = 0
    let result.path = ''
  endif
  return result
endfunction

function! s:ThemeDetector_get_wp_path(found) dict
  let parent_path = fnamemodify(a:found, ':h')
  let core_path = fnamemodify(a:found, ':h:h:h:h')
  if self.is_core_path(core_path)
    return core_path
  else
    return parent_path
  endif
endfunction

function! s:ThemeDetector_has_theme_header(file) dict
  let lines = readfile(a:file)
  for line in lines
    if line =~# '^\s*Theme Name:'
      return 1
    endif
  endfor
  return 0
endfunction

function! s:ThemeDetector_get_type() dict
  return 'theme'
endfunction

function! s:BufferConstructor(path)
  let bufferObj = {}
  let bufferObj.path = a:path
  let bufferObj.did_scan = 0
  let bufferObj.project_path = ''
  let bufferObj.type = 'unknown'
  let bufferObj.scan = function('<SNR>' . s:SID() . '_Buffer_scan')
  let bufferObj.get_detectors = function('<SNR>' . s:SID() . '_Buffer_get_detectors')
  let bufferObj.get_type = function('<SNR>' . s:SID() . '_Buffer_get_type')
  let bufferObj.get_project_path = function('<SNR>' . s:SID() . '_Buffer_get_project_path')
  let bufferObj.get_path = function('<SNR>' . s:SID() . '_Buffer_get_path')
  let bufferObj.get_full_path = function('<SNR>' . s:SID() . '_Buffer_get_full_path')
  let bufferObj.get_parent_path = function('<SNR>' . s:SID() . '_Buffer_get_parent_path')
  let bufferObj.to_full_path = function('<SNR>' . s:SID() . '_Buffer_to_full_path')
  let bufferObj.destroy = function('<SNR>' . s:SID() . '_Buffer_destroy')
  return bufferObj
endfunction

function! s:Buffer_scan() dict
  for detector in self.get_detectors()
    let result = detector.detect(self.get_parent_path())
    if result.status ==# 1
      let self.type = detector.get_type()
      let self.project_path = self.to_full_path(result.path)
      return 1
    endif
  endfor
  return 0
endfunction

function! s:Buffer_get_detectors() dict
  let detectors = []
  call add(detectors, s:CoreDetectorConstructor())
  call add(detectors, s:WpCliDetectorConstructor())
  call add(detectors, s:PluginDetectorConstructor())
  call add(detectors, s:ThemeDetectorConstructor())
  return detectors
endfunction

function! s:Buffer_get_type() dict
  if !(self.did_scan)
    call self.scan()
  endif
  return self.type
endfunction

function! s:Buffer_get_project_path() dict
  if !(self.did_scan)
    call self.scan()
  endif
  return self.project_path
endfunction

function! s:Buffer_get_path() dict
  return self.path
endfunction

function! s:Buffer_get_full_path() dict
  if !(has_key(self, 'full_path'))
    let self.full_path = self.to_full_path(self.path)
  endif
  return self.full_path
endfunction

function! s:Buffer_get_parent_path() dict
  if !(has_key(self, 'parent_path'))
    let self.parent_path = self.to_full_path(fnamemodify(self.path, ':h'))
  endif
  return self.parent_path
endfunction

function! s:Buffer_to_full_path(path) dict
  let full_path = fnamemodify(a:path, ':p')
  if full_path =~# '/$'
    let full_path = strpart(full_path, 0, len(full_path) - 1)
  endif
  return full_path
endfunction

function! s:Buffer_destroy() dict
  unlet self.path
endfunction

function! s:BufferCollectionConstructor()
  let bufferCollectionObj = {}
  let bufferCollectionObj.buffers = {}
  let bufferCollectionObj.is_buffer_collection = 1
  let bufferCollectionObj.size = function('<SNR>' . s:SID() . '_BufferCollection_size')
  let bufferCollectionObj.add = function('<SNR>' . s:SID() . '_BufferCollection_add')
  let bufferCollectionObj.remove = function('<SNR>' . s:SID() . '_BufferCollection_remove')
  let bufferCollectionObj.contains = function('<SNR>' . s:SID() . '_BufferCollection_contains')
  let bufferCollectionObj.contains_path = function('<SNR>' . s:SID() . '_BufferCollection_contains_path')
  let bufferCollectionObj.buffer_for = function('<SNR>' . s:SID() . '_BufferCollection_buffer_for')
  let bufferCollectionObj.clear = function('<SNR>' . s:SID() . '_BufferCollection_clear')
  let bufferCollectionObj.set_current = function('<SNR>' . s:SID() . '_BufferCollection_set_current')
  let bufferCollectionObj.get_current = function('<SNR>' . s:SID() . '_BufferCollection_get_current')
  return bufferCollectionObj
endfunction

function! s:BufferCollection_size() dict
  return len(self.buffers)
endfunction

function! s:BufferCollection_add(buffer) dict
  let path = a:buffer.get_full_path()
  let self.buffers[path] = a:buffer
endfunction

function! s:BufferCollection_remove(buffer) dict
  let path = a:buffer.get_full_path()
  unlet self.buffers[path]
endfunction

function! s:BufferCollection_contains(buffer) dict
  return self.contains_path(a:buffer.get_full_path())
endfunction

function! s:BufferCollection_contains_path(path) dict
  return has_key(self.buffers, a:path)
endfunction

function! s:BufferCollection_buffer_for(path) dict
  return self.buffers[a:path]
endfunction

function! s:BufferCollection_clear() dict
  for buffer in values(self.buffers)
    call buffer.destroy()
  endfor
  let self.buffers = {}
endfunction

function! s:BufferCollection_set_current(buffer) dict
  if !(self.contains(a:buffer))
    call self.add(a:buffer)
  endif
  let self.current = a:buffer
endfunction

function! s:BufferCollection_get_current() dict
  return self.current
endfunction

" included: 'project_collection.riml'
" included: 'project.riml'
" included: 'wpcli_path.riml'
function! s:WpCliPathConstructor()
  let wpCliPathObj = {}
  let wpCliPathObj.did_find = 0
  let wpCliPathObj.get_path = function('<SNR>' . s:SID() . '_WpCliPath_get_path')
  let wpCliPathObj.exists = function('<SNR>' . s:SID() . '_WpCliPath_exists')
  let wpCliPathObj.find = function('<SNR>' . s:SID() . '_WpCliPath_find')
  let wpCliPathObj.is_executable = function('<SNR>' . s:SID() . '_WpCliPath_is_executable')
  let wpCliPathObj.vendor_cli_path = function('<SNR>' . s:SID() . '_WpCliPath_vendor_cli_path')
  return wpCliPathObj
endfunction

function! s:WpCliPath_get_path(root) dict
  if !(self.did_find)
    let self.cli_path = self.find(a:root)
    let self.did_find = 1
  endif
  return self.cli_path
endfunction

function! s:WpCliPath_exists(root) dict
  return self.get_path(a:root) !=# ''
endfunction

function! s:WpCliPath_find(root) dict
  let cli_path = self.vendor_cli_path(a:root)
  if self.is_executable(cli_path)
    return cli_path
  elseif self.is_executable('wp')
    return 'wp'
  else
    return ''
  endif
endfunction

function! s:WpCliPath_is_executable(path) dict
  if has_key(self, 'mock_is_executable')
    return self.mock_is_executable
  else
    return executable(a:path)
  endif
endfunction

function! s:WpCliPath_vendor_cli_path(root) dict
  return a:root . "/vendor/bin/wp"
endfunction

" included: 'wpcli_config.riml'
function! s:WpCliConfigConstructor()
  let wpCliConfigObj = {}
  let wpCliConfigObj.is_wpcli_config = 1
  let wpCliConfigObj.did_read = 0
  let wpCliConfigObj.params = {}
  let wpCliConfigObj.pattern = '\v^(.+):\s*(.+)$'
  let wpCliConfigObj.get_config_param = function('<SNR>' . s:SID() . '_WpCliConfig_get_config_param')
  let wpCliConfigObj.load = function('<SNR>' . s:SID() . '_WpCliConfig_load')
  let wpCliConfigObj.parse = function('<SNR>' . s:SID() . '_WpCliConfig_parse')
  let wpCliConfigObj.parse_line = function('<SNR>' . s:SID() . '_WpCliConfig_parse_line')
  let wpCliConfigObj.read = function('<SNR>' . s:SID() . '_WpCliConfig_read')
  let wpCliConfigObj.get_config_path = function('<SNR>' . s:SID() . '_WpCliConfig_get_config_path')
  let wpCliConfigObj.local_config_path_for = function('<SNR>' . s:SID() . '_WpCliConfig_local_config_path_for')
  let wpCliConfigObj.config_path_for = function('<SNR>' . s:SID() . '_WpCliConfig_config_path_for')
  let wpCliConfigObj.global_config_path_for = function('<SNR>' . s:SID() . '_WpCliConfig_global_config_path_for')
  return wpCliConfigObj
endfunction

function! s:WpCliConfig_get_config_param(param) dict
  if has_key(self.params, a:param)
    return self.params[a:param]
  else
    return ''
  endif
endfunction

function! s:WpCliConfig_load(root) dict
  let lines = self.read(a:root)
  call self.parse(lines)
endfunction

function! s:WpCliConfig_parse(lines) dict
  for line in a:lines
    let result = self.parse_line(line)
    if result.status
      let self.params[result.param] = result.value
    endif
  endfor
endfunction

function! s:WpCliConfig_parse_line(line) dict
  let matches = matchlist(a:line, self.pattern)
  let result = {}
  if len(matches) ># 0 && matches[2] !=# ' '
    let result.status = 1
    let result.param = matches[1]
    let result.value = matches[2]
  else
    let result.status = 0
  endif
  return result
endfunction

function! s:WpCliConfig_read(root) dict
  let config = self.get_config_path(a:root)
  if config !=# ''
    return readfile(config)
  else
    return []
  endif
endfunction

function! s:WpCliConfig_get_config_path(root) dict
  if has_key(self, 'config_path')
    return self.config_path
  endif
  let config = self.local_config_path_for(a:root)
  if !(filereadable(config))
    let config = self.config_path_for(a:root)
  endif
  if !(filereadable(config))
    let config = self.global_config_path_for(a:root)
  endif
  if !(filereadable(config))
    let config = ''
  endif
  let self.config_path = config
  return config
endfunction

function! s:WpCliConfig_local_config_path_for(root) dict
  return a:root . "/wp-cli.local.yml"
endfunction

function! s:WpCliConfig_config_path_for(root) dict
  return a:root . "/wp-cli.yml"
endfunction

function! s:WpCliConfig_global_config_path_for(root) dict
  return expand("~/.wp-cli/config.yml")
endfunction

" included: 'wpcli_printer.riml'
function! s:WpCliPrinterConstructor()
  let wpCliPrinterObj = {}
  let wpCliPrinterObj.is_wpcli_printer = 1
  let wpCliPrinterObj.print = function('<SNR>' . s:SID() . '_WpCliPrinter_print')
  let wpCliPrinterObj.print_json = function('<SNR>' . s:SID() . '_WpCliPrinter_print_json')
  let wpCliPrinterObj.print_text = function('<SNR>' . s:SID() . '_WpCliPrinter_print_text')
  let wpCliPrinterObj.replace = function('<SNR>' . s:SID() . '_WpCliPrinter_replace')
  let wpCliPrinterObj.get_command_pattern = function('<SNR>' . s:SID() . '_WpCliPrinter_get_command_pattern')
  let wpCliPrinterObj.get_help_pattern = function('<SNR>' . s:SID() . '_WpCliPrinter_get_help_pattern')
  let wpCliPrinterObj.get_command_replacement = function('<SNR>' . s:SID() . '_WpCliPrinter_get_command_replacement')
  let wpCliPrinterObj.get_help_replacement = function('<SNR>' . s:SID() . '_WpCliPrinter_get_help_replacement')
  let wpCliPrinterObj.print_line = function('<SNR>' . s:SID() . '_WpCliPrinter_print_line')
  let wpCliPrinterObj.replace_tabs = function('<SNR>' . s:SID() . '_WpCliPrinter_replace_tabs')
  let wpCliPrinterObj.replace_colors = function('<SNR>' . s:SID() . '_WpCliPrinter_replace_colors')
  let wpCliPrinterObj.is_json = function('<SNR>' . s:SID() . '_WpCliPrinter_is_json')
  let wpCliPrinterObj.lines_for = function('<SNR>' . s:SID() . '_WpCliPrinter_lines_for')
  return wpCliPrinterObj
endfunction

function! s:WpCliPrinter_print(cmd_name, result) dict
  if self.is_json(a:result)
    call self.print_json(a:cmd_name, a:result)
  else
    call self.print_text(a:cmd_name, a:result)
  endif
endfunction

function! s:WpCliPrinter_print_json(cmd_name, json) dict
  call s:echo_msg(a:json)
endfunction

function! s:WpCliPrinter_print_text(cmd_name, text) dict
  let text = self.replace(a:cmd_name, a:text)
  let lines = self.lines_for(text)
  for line in lines
    call self.print_line(line)
  endfor
endfunction

function! s:WpCliPrinter_replace(cmd_name, text) dict
  if a:cmd_name !=# ''
    let result = substitute(a:text, self.get_command_pattern(a:cmd_name), self.get_command_replacement(a:cmd_name), 'g')
    let result = substitute(result, self.get_help_pattern(a:cmd_name), self.get_help_replacement(a:cmd_name), 'g')
    let result = self.replace_colors(result)
  else
    let result = a:text
  endif
  return result
endfunction

function! s:WpCliPrinter_get_command_pattern(cmd_name) dict
  return "\\Vwp " . a:cmd_name
endfunction

function! s:WpCliPrinter_get_help_pattern(cmd_name) dict
  return "\\Vwp help " . a:cmd_name . " <command>"
endfunction

function! s:WpCliPrinter_get_command_replacement(cmd_name) dict
  let name = substitute(a:cmd_name, '\V-', '', 'g')
  return "W" . name
endfunction

function! s:WpCliPrinter_get_help_replacement(cmd_name) dict
  return self.get_command_replacement(a:cmd_name) . "!"
endfunction

function! s:WpCliPrinter_print_line(line) dict
  let text = self.replace_tabs(a:line)
  call s:echo_msg(text)
endfunction

function! s:WpCliPrinter_replace_tabs(line) dict
  return substitute(a:line, "\t", "  ", 'g')
endfunction

function! s:WpCliPrinter_replace_colors(line) dict
  return substitute(a:line, '\e\[[0-9;]\+[mK]', '', 'g')
endfunction

function! s:WpCliPrinter_is_json(result) dict
  return type(a:result) ==# type({})
endfunction

function! s:WpCliPrinter_lines_for(result) dict
  return split(a:result, "\n")
endfunction

" included: 'wpcli_completer.riml'
function! s:WpCliCompleterConstructor()
  let wpCliCompleterObj = {}
  let wpCliCompleterObj.needs = function('<SNR>' . s:SID() . '_WpCliCompleter_needs')
  let wpCliCompleterObj.complete = function('<SNR>' . s:SID() . '_WpCliCompleter_complete')
  let wpCliCompleterObj.trim_choices = function('<SNR>' . s:SID() . '_WpCliCompleter_trim_choices')
  let wpCliCompleterObj.trim = function('<SNR>' . s:SID() . '_WpCliCompleter_trim')
  let wpCliCompleterObj.to_complete_args = function('<SNR>' . s:SID() . '_WpCliCompleter_to_complete_args')
  let wpCliCompleterObj.to_cursor_arg = function('<SNR>' . s:SID() . '_WpCliCompleter_to_cursor_arg')
  let wpCliCompleterObj.to_line_arg = function('<SNR>' . s:SID() . '_WpCliCompleter_to_line_arg')
  let wpCliCompleterObj.to_wpcli_line = function('<SNR>' . s:SID() . '_WpCliCompleter_to_wpcli_line')
  return wpCliCompleterObj
endfunction

function! s:WpCliCompleter_needs() dict
  return ['wpcli']
endfunction

function! s:WpCliCompleter_complete(cmd_name, word, cmd_line, cursor) dict
  let args = self.to_complete_args(a:cmd_name, a:word, a:cmd_line, a:cursor)
  let result = call(self.wpcli['run'], args, self.wpcli)
  let choices = split(result, "\n")
  let choices = self.trim_choices(choices)
  return choices
endfunction

function! s:WpCliCompleter_trim_choices(choices) dict
  return map(a:choices, 'self.trim(v:val)')
endfunction

function! s:WpCliCompleter_trim(text) dict
  return substitute(a:text, '^\s*\(.\{-}\)\s*$', '\1', '')
endfunction

function! s:WpCliCompleter_to_complete_args(cmd_name, word, cmd_line, cursor) dict
  let args = []
  call add(args, 'cli')
  call add(args, 'completions')
  call add(args, self.to_line_arg(a:cmd_name, a:cmd_line))
  call add(args, self.to_cursor_arg(a:cmd_name, a:cursor))
  return args
endfunction

function! s:WpCliCompleter_to_cursor_arg(cmd_name, cursor) dict
  let arg = a:cursor + 2
  return "--point=" . arg
endfunction

function! s:WpCliCompleter_to_line_arg(cmd_name, cmd_line) dict
  let wpcli_line = self.to_wpcli_line(a:cmd_name, a:cmd_line)
  return "--line=\"" . wpcli_line . "\""
endfunction

function! s:WpCliCompleter_to_wpcli_line(cmd_name, cmd_line) dict
  let pattern = "\\VW" . a:cmd_name
  let replacement = "wp " . a:cmd_name
  return substitute(a:cmd_line, pattern, replacement, '')
endfunction

" included: 'wpcli_runner.riml'
function! s:WpCliRunnerConstructor()
  let wpCliRunnerObj = {}
  let wpCliRunnerObj.needs = function('<SNR>' . s:SID() . '_WpCliRunner_needs')
  let wpCliRunnerObj.run = function('<SNR>' . s:SID() . '_WpCliRunner_run')
  let wpCliRunnerObj.to_cli_params = function('<SNR>' . s:SID() . '_WpCliRunner_to_cli_params')
  let wpCliRunnerObj.wants_help = function('<SNR>' . s:SID() . '_WpCliRunner_wants_help')
  return wpCliRunnerObj
endfunction

function! s:WpCliRunner_needs() dict
  return ['wpcli', 'wpcli_printer']
endfunction

function! s:WpCliRunner_run(cmd_name, params, opts) dict
  let cli_params = self.to_cli_params(a:cmd_name, a:params, a:opts)
  let result = call(self.wpcli['run'], cli_params, self.wpcli)
  if !(has_key(a:opts, 'silent_cmd'))
    call self.wpcli_printer.print(a:cmd_name, result)
  endif
  return result
endfunction

function! s:WpCliRunner_to_cli_params(cmd_name, params, opts) dict
  if self.wants_help(a:opts)
    let cli_params = [a:cmd_name] + a:params + ['--help']
  else
    let cli_params = [a:cmd_name] + a:params
  endif
  return cli_params
endfunction

function! s:WpCliRunner_wants_help(opts) dict
  return has_key(a:opts, 'bang') && a:opts.bang
endfunction

" included: 'post.riml'
function! s:PostConstructor()
  let postObj = {}
  let postObj.is_post = 1
  let postObj.needs = function('<SNR>' . s:SID() . '_Post_needs')
  let postObj.create = function('<SNR>' . s:SID() . '_Post_create')
  let postObj.update = function('<SNR>' . s:SID() . '_Post_update')
  let postObj.find = function('<SNR>' . s:SID() . '_Post_find')
  let postObj.to_arg = function('<SNR>' . s:SID() . '_Post_to_arg')
  let postObj.to_post_id = function('<SNR>' . s:SID() . '_Post_to_post_id')
  return postObj
endfunction

function! s:Post_needs() dict
  return ['wpcli']
endfunction

function! s:Post_create(post_content, params) dict
  let cli_params = ['post', 'create', self.to_arg('post_content', a:post_content), '--porcelain']
  let cli_params += a:params
  let result = call(self.wpcli['run'], cli_params, self.wpcli)
  return self.to_post_id(result)
endfunction

function! s:Post_update(post_id, post_content, params) dict
  let cli_params = ['post', 'update', a:post_id, self.to_arg('post_content', a:post_content)]
  let cli_params += a:params
  return call(self.wpcli['run'], cli_params, self.wpcli)
endfunction

function! s:Post_find(post_id) dict
  let cli_params = ['post', 'get', a:post_id, '--format=json']
  let result = call(self.wpcli['run'], cli_params, self.wpcli)
  if has_key(result, 'post_content')
    return result['post_content']
  else
    return ''
  endif
endfunction

function! s:Post_to_arg(name, value) dict
  return "--" . a:name . "=" . shellescape(a:value)
endfunction

function! s:Post_to_post_id(result) dict
  let lines = split(a:result, "\n")
  if len(lines) >=# 0
    let post_id = lines[0]
  else
    let post_id = 0
  endif
  return post_id
endfunction

" included: 'ctags_builder.riml'
function! s:CTagsBuilderConstructor()
  let cTagsBuilderObj = {}
  let cTagsBuilderObj.is_ctags_builder = 1
  let cTagsBuilderObj.project_path = ''
  let cTagsBuilderObj.needs = function('<SNR>' . s:SID() . '_CTagsBuilder_needs')
  let cTagsBuilderObj.clean = function('<SNR>' . s:SID() . '_CTagsBuilder_clean')
  let cTagsBuilderObj.generate = function('<SNR>' . s:SID() . '_CTagsBuilder_generate')
  let cTagsBuilderObj.set_project_path = function('<SNR>' . s:SID() . '_CTagsBuilder_set_project_path')
  let cTagsBuilderObj.get_project_path = function('<SNR>' . s:SID() . '_CTagsBuilder_get_project_path')
  let cTagsBuilderObj.get_tags_name = function('<SNR>' . s:SID() . '_CTagsBuilder_get_tags_name')
  let cTagsBuilderObj.get_project_tags = function('<SNR>' . s:SID() . '_CTagsBuilder_get_project_tags')
  let cTagsBuilderObj.get_executable = function('<SNR>' . s:SID() . '_CTagsBuilder_get_executable')
  let cTagsBuilderObj.has_executable = function('<SNR>' . s:SID() . '_CTagsBuilder_has_executable')
  let cTagsBuilderObj.has_tags = function('<SNR>' . s:SID() . '_CTagsBuilder_has_tags')
  let cTagsBuilderObj.get_with_dir = function('<SNR>' . s:SID() . '_CTagsBuilder_get_with_dir')
  let cTagsBuilderObj.run = function('<SNR>' . s:SID() . '_CTagsBuilder_run')
  let cTagsBuilderObj.build = function('<SNR>' . s:SID() . '_CTagsBuilder_build')
  return cTagsBuilderObj
endfunction

function! s:CTagsBuilder_needs() dict
  return ['with_dir', 'ctags_command_builder']
endfunction

function! s:CTagsBuilder_clean() dict
  let tags = self.get_project_tags()
  if filereadable(tags)
    call delete(tags)
  endif
endfunction

function! s:CTagsBuilder_generate() dict
  if !(self.has_executable())
    return 0
  endif
  let cmd = self.build()
  let with_dir = self.get_with_dir()
  let [error_code, result] = self.with_dir.run(self, 'run', [cmd])
  return error_code ==# 0
endfunction

function! s:CTagsBuilder_set_project_path(project_path) dict
  let self.project_path = a:project_path
endfunction

function! s:CTagsBuilder_get_project_path() dict
  return self.project_path
endfunction

function! s:CTagsBuilder_get_tags_name() dict
  return self.ctags_command_builder.get_tags_name()
endfunction

function! s:CTagsBuilder_get_project_tags() dict
  return self.get_project_path() . "/" . self.get_tags_name()
endfunction

function! s:CTagsBuilder_get_executable() dict
  return self.ctags_command_builder.get_executable()
endfunction

function! s:CTagsBuilder_has_executable() dict
  return self.ctags_command_builder.has_executable()
endfunction

function! s:CTagsBuilder_has_tags() dict
  return filereadable(self.get_project_tags())
endfunction

function! s:CTagsBuilder_get_with_dir() dict
  let with_dir = self.with_dir
  call with_dir.set_dir(self.get_project_path())
  return with_dir
endfunction

function! s:CTagsBuilder_run(cmd) dict
  let result = system(a:cmd)
  return [v:shell_error, result]
endfunction

function! s:CTagsBuilder_build() dict
  return self.ctags_command_builder.build()
endfunction

" included: 'leet_convertor.riml'
function! s:LeetConvertorConstructor()
  let leetConvertorObj = {}
  let leetConvertorObj.convert = function('<SNR>' . s:SID() . '_LeetConvertor_convert')
  let leetConvertorObj.convert_char = function('<SNR>' . s:SID() . '_LeetConvertor_convert_char')
  let leetConvertorObj.get_basic_dict = function('<SNR>' . s:SID() . '_LeetConvertor_get_basic_dict')
  let leetConvertorObj.get_lower_case_dict = function('<SNR>' . s:SID() . '_LeetConvertor_get_lower_case_dict')
  return leetConvertorObj
endfunction

function! s:LeetConvertor_convert(text) dict
  let leet = ''
  let total = len(a:text)
  for i in range(0, total)
    let char = a:text[i]
    let new_char = self.convert_char(char)
    let leet .= new_char
  endfor
  return leet
endfunction

function! s:LeetConvertor_convert_char(char) dict
  if !(has_key(self, 'basic_dict'))
    let self.basic_dict = self.get_basic_dict()
  endif
  if has_key(self.basic_dict, a:char)
    return self.basic_dict[a:char]
  else
    return a:char
  endif
endfunction

function! s:LeetConvertor_get_basic_dict() dict
  let d = self.get_lower_case_dict()
  let basic_dict = {}
  for char in keys(d)
    let value = d[char]
    let upper_char = toupper(char)
    let basic_dict[char] = value
    let basic_dict[upper_char] = value
  endfor
  return basic_dict
endfunction

function! s:LeetConvertor_get_lower_case_dict() dict
  let d = {}
  let d['a'] = '4'
  let d['b'] = '8'
  let d['c'] = 'c'
  let d['d'] = 'd'
  let d['e'] = '3'
  let d['f'] = 'ph'
  let d['g'] = '9'
  let d['h'] = 'h'
  let d['i'] = '1'
  let d['j'] = 'j'
  let d['k'] = 'k'
  let d['l'] = 'l'
  let d['m'] = 'm'
  let d['n'] = 'n'
  let d['o'] = '0'
  let d['p'] = 'p'
  let d['q'] = 'q'
  let d['r'] = 'r'
  let d['s'] = '5'
  let d['t'] = '7'
  let d['u'] = 'u'
  let d['v'] = 'v'
  let d['w'] = 'w'
  let d['x'] = 'x'
  let d['y'] = 'y'
  let d['z'] = '2'
  return d
endfunction

" included: 'ctags_command_builder.riml'
function! s:CTagsCommandBuilderConstructor()
  let cTagsCommandBuilderObj = {}
  let cTagsCommandBuilderObj.needs = function('<SNR>' . s:SID() . '_CTagsCommandBuilder_needs')
  let cTagsCommandBuilderObj.build = function('<SNR>' . s:SID() . '_CTagsCommandBuilder_build')
  let cTagsCommandBuilderObj.get_exclude_dirs = function('<SNR>' . s:SID() . '_CTagsCommandBuilder_get_exclude_dirs')
  let cTagsCommandBuilderObj.to_invocation_regex = function('<SNR>' . s:SID() . '_CTagsCommandBuilder_to_invocation_regex')
  let cTagsCommandBuilderObj.to_listener_regex = function('<SNR>' . s:SID() . '_CTagsCommandBuilder_to_listener_regex')
  let cTagsCommandBuilderObj.to_tag_regex = function('<SNR>' . s:SID() . '_CTagsCommandBuilder_to_tag_regex')
  let cTagsCommandBuilderObj.to_kind = function('<SNR>' . s:SID() . '_CTagsCommandBuilder_to_kind')
  let cTagsCommandBuilderObj.to_capture_group = function('<SNR>' . s:SID() . '_CTagsCommandBuilder_to_capture_group')
  let cTagsCommandBuilderObj.to_invocation_pattern = function('<SNR>' . s:SID() . '_CTagsCommandBuilder_to_invocation_pattern')
  let cTagsCommandBuilderObj.to_listener_pattern = function('<SNR>' . s:SID() . '_CTagsCommandBuilder_to_listener_pattern')
  let cTagsCommandBuilderObj.get_tags_name = function('<SNR>' . s:SID() . '_CTagsCommandBuilder_get_tags_name')
  let cTagsCommandBuilderObj.get_executable = function('<SNR>' . s:SID() . '_CTagsCommandBuilder_get_executable')
  let cTagsCommandBuilderObj.has_executable = function('<SNR>' . s:SID() . '_CTagsCommandBuilder_has_executable')
  let cTagsCommandBuilderObj.has_exuberant_executable = function('<SNR>' . s:SID() . '_CTagsCommandBuilder_has_exuberant_executable')
  let cTagsCommandBuilderObj.to_leet = function('<SNR>' . s:SID() . '_CTagsCommandBuilder_to_leet')
  let cTagsCommandBuilderObj.get_action_uid = function('<SNR>' . s:SID() . '_CTagsCommandBuilder_get_action_uid')
  let cTagsCommandBuilderObj.get_action_listener_uid = function('<SNR>' . s:SID() . '_CTagsCommandBuilder_get_action_listener_uid')
  let cTagsCommandBuilderObj.get_filter_uid = function('<SNR>' . s:SID() . '_CTagsCommandBuilder_get_filter_uid')
  let cTagsCommandBuilderObj.get_filter_listener_uid = function('<SNR>' . s:SID() . '_CTagsCommandBuilder_get_filter_listener_uid')
  return cTagsCommandBuilderObj
endfunction

function! s:CTagsCommandBuilder_needs() dict
  return ['leet_convertor']
endfunction

function! s:CTagsCommandBuilder_build() dict
  let cmd = self.get_executable()
  let cmd .= " -R"
  let cmd .= " -f " . shellescape(self.get_tags_name())
  let cmd .= " --tag-relative"
  let re = self.to_invocation_regex('action', 'a', 'do_action')
  let cmd .= " --regex-PHP=" . shellescape(re)
  let re = self.to_listener_regex('alistener', 'l', 'add_action')
  let cmd .= " --regex-PHP=" . shellescape(re)
  let re = self.to_invocation_regex('filter', 'r', 'apply_filters')
  let cmd .= " --regex-PHP=" . shellescape(re)
  let re = self.to_listener_regex('flistener', 'e', 'add_filter')
  let cmd .= " --regex-PHP=" . shellescape(re)
  let dirs = self.get_exclude_dirs()
  for dir in dirs
    let cmd .= " --exclude=" . dir
  endfor
  let cmd .= " ."
  return cmd
endfunction

function! s:CTagsCommandBuilder_get_exclude_dirs() dict
  let dirs = []
  call add(dirs, '.git')
  call add(dirs, '.hg')
  call add(dirs, 'node_modules')
  call add(dirs, 'bower_components')
  call add(dirs, 'build')
  call add(dirs, 'dist')
  call add(dirs, 'vendor')
  return dirs
endfunction

function! s:CTagsCommandBuilder_to_invocation_regex(type_name, type_letter, method) dict
  let pattern = self.to_invocation_pattern(a:method)
  return self.to_tag_regex(a:type_name, a:type_letter, a:method, pattern)
endfunction

function! s:CTagsCommandBuilder_to_listener_regex(type_name, type_letter, method) dict
  let pattern = self.to_listener_pattern(a:method)
  return self.to_tag_regex(a:type_name, a:type_letter, a:method, pattern)
endfunction

function! s:CTagsCommandBuilder_to_tag_regex(type_name, type_letter, method, pattern) dict
  let re = "/"
  let re .= a:pattern
  let re .= "/"
  let re .= self.to_capture_group(a:type_name)
  let re .= "/"
  let re .= self.to_kind(a:type_name, a:type_letter)
  let re .= "/"
  return re
endfunction

function! s:CTagsCommandBuilder_to_kind(letter, label) dict
  return a:label . "," . a:letter
endfunction

function! s:CTagsCommandBuilder_to_capture_group(type_name, ...) dict
  let __splat_var_cpy = copy(a:000)
  if !empty(__splat_var_cpy)
    let group_num = remove(__splat_var_cpy, 0)
  else
    let group_num = 1
  endif
  let uid = self.to_leet(a:type_name)
  return uid . "_\\" . group_num
endfunction

function! s:CTagsCommandBuilder_to_invocation_pattern(method) dict
  let pattern = a:method
  let pattern .= "[a-z_]*\\(\\s*['\"]([a-z_]+)['\"]\\s*.*\)"
  return pattern
endfunction

function! s:CTagsCommandBuilder_to_listener_pattern(method) dict
  let pattern = a:method
  let pattern .= "\\s*\\(\\s*['\"]([a-z_]+)['\"]\\s*.*\)"
  return pattern
endfunction

function! s:CTagsCommandBuilder_get_tags_name() dict
  if exists('g:wordpress_vim_tags_file_name')
    return g:wordpress_vim_tags_file_name
  else
    return "tags"
  endif
endfunction

function! s:CTagsCommandBuilder_get_executable() dict
  if exists('g:wordpress_vim_ctags_path')
    let ctags = g:wordpress_vim_ctags_path
  else
    let ctags = 'ctags'
  endif
  return ctags
endfunction

function! s:CTagsCommandBuilder_has_executable() dict
  return executable(self.get_executable()) && self.has_exuberant_executable()
endfunction

function! s:CTagsCommandBuilder_has_exuberant_executable() dict
  if has_key(self, 'exuberant_found')
    return self.exuberant_found
  endif
  let ctags_version = system(self.get_executable() . ' --version')
  if ctags_version =~# 'Exuberant Ctags'
    let self.exuberant_found = 1
  else
    let self.exuberant_found = 0
  endif
  return self.exuberant_found
endfunction

function! s:CTagsCommandBuilder_to_leet(key) dict
  let variable = a:key . "_uid"
  if !(has_key(self, variable))
    let self[variable] = self.leet_convertor.convert(a:key)
  endif
  return self[variable]
endfunction

function! s:CTagsCommandBuilder_get_action_uid() dict
  return self.to_leet('action')
endfunction

function! s:CTagsCommandBuilder_get_action_listener_uid() dict
  return self.to_leet('alistener')
endfunction

function! s:CTagsCommandBuilder_get_filter_uid() dict
  return self.to_leet('filter')
endfunction

function! s:CTagsCommandBuilder_get_filter_listener_uid() dict
  return self.to_leet('flistener')
endfunction

" included: 'command_registry.riml'
" included: 'command_builder.riml'
function! s:CommandBuilderConstructor()
  let commandBuilderObj = {}
  let commandBuilderObj.cmd_options = ''
  let commandBuilderObj.cmd_params = ''
  let commandBuilderObj.cmd_name = ''
  let commandBuilderObj.cmd_repr = ''
  let commandBuilderObj.ex_cmd_name = 'command!'
  let commandBuilderObj.ex_cmd = function('<SNR>' . s:SID() . '_CommandBuilder_ex_cmd')
  let commandBuilderObj.append_to = function('<SNR>' . s:SID() . '_CommandBuilder_append_to')
  let commandBuilderObj.option = function('<SNR>' . s:SID() . '_CommandBuilder_option')
  let commandBuilderObj.options = function('<SNR>' . s:SID() . '_CommandBuilder_options')
  let commandBuilderObj.param = function('<SNR>' . s:SID() . '_CommandBuilder_param')
  let commandBuilderObj.name = function('<SNR>' . s:SID() . '_CommandBuilder_name')
  let commandBuilderObj.repr = function('<SNR>' . s:SID() . '_CommandBuilder_repr')
  let commandBuilderObj.build = function('<SNR>' . s:SID() . '_CommandBuilder_build')
  return commandBuilderObj
endfunction

function! s:CommandBuilder_ex_cmd(ex_cmd_name) dict
  let self.ex_cmd_name = a:ex_cmd_name
endfunction

function! s:CommandBuilder_append_to(key, str) dict
  let key = "cmd_" . a:key
  let self[key] = self[key] . " " . a:str
endfunction

function! s:CommandBuilder_option(name, value) dict
  if type(a:value) ==# type(1)
    if a:value ==# 1
      call self.append_to('options', "-" . a:name)
    endif
  else
    call self.append_to('options', "-" . a:name . "=" . a:value)
  endif
endfunction

function! s:CommandBuilder_options(options) dict
  for [name, value] in items(a:options)
    call self.option(name, value)
  endfor
endfunction

function! s:CommandBuilder_param(name, value) dict
  call self.append_to('params', a:name . " " . a:value)
endfunction

function! s:CommandBuilder_name(cmd_name) dict
  if a:cmd_name =~# '_'
    let self.cmd_name = substitute(a:cmd_name, '_', '', 'g')
  else
    let self.cmd_name = a:cmd_name
  endif
endfunction

function! s:CommandBuilder_repr(repr) dict
  let self.cmd_repr = a:repr
endfunction

function! s:CommandBuilder_build() dict
  let cmd = self.ex_cmd_name . ' '
  let cmd .= self.cmd_options . ' '
  let cmd .= self.cmd_params . ' '
  let cmd .= self.cmd_name . ' '
  let cmd .= self.cmd_repr
  return cmd
endfunction

" included: 'ctrlp_extension.riml'
function! s:CtrlPExtensionConstructor()
  let ctrlPExtensionObj = {}
  let ctrlPExtensionObj.id_counter = 0
  let ctrlPExtensionObj.enabled = 0
  let ctrlPExtensionObj.inited = 0
  let ctrlPExtensionObj.next_id = function('<SNR>' . s:SID() . '_CtrlPExtension_next_id')
  let ctrlPExtensionObj.set_options = function('<SNR>' . s:SID() . '_CtrlPExtension_set_options')
  let ctrlPExtensionObj.get_options = function('<SNR>' . s:SID() . '_CtrlPExtension_get_options')
  let ctrlPExtensionObj.set_name = function('<SNR>' . s:SID() . '_CtrlPExtension_set_name')
  let ctrlPExtensionObj.get_name = function('<SNR>' . s:SID() . '_CtrlPExtension_get_name')
  let ctrlPExtensionObj.set_agent = function('<SNR>' . s:SID() . '_CtrlPExtension_set_agent')
  let ctrlPExtensionObj.get_agent = function('<SNR>' . s:SID() . '_CtrlPExtension_get_agent')
  let ctrlPExtensionObj.get_ext_vars = function('<SNR>' . s:SID() . '_CtrlPExtension_get_ext_vars')
  let ctrlPExtensionObj.get_id = function('<SNR>' . s:SID() . '_CtrlPExtension_get_id')
  let ctrlPExtensionObj.get_ex_cmd_name = function('<SNR>' . s:SID() . '_CtrlPExtension_get_ex_cmd_name')
  let ctrlPExtensionObj.enable = function('<SNR>' . s:SID() . '_CtrlPExtension_enable')
  let ctrlPExtensionObj.disable = function('<SNR>' . s:SID() . '_CtrlPExtension_disable')
  let ctrlPExtensionObj.show = function('<SNR>' . s:SID() . '_CtrlPExtension_show')
  let ctrlPExtensionObj.do_init = function('<SNR>' . s:SID() . '_CtrlPExtension_do_init')
  let ctrlPExtensionObj.do_accept = function('<SNR>' . s:SID() . '_CtrlPExtension_do_accept')
  let ctrlPExtensionObj.do_enter = function('<SNR>' . s:SID() . '_CtrlPExtension_do_enter')
  let ctrlPExtensionObj.do_exit = function('<SNR>' . s:SID() . '_CtrlPExtension_do_exit')
  let ctrlPExtensionObj.do_opts = function('<SNR>' . s:SID() . '_CtrlPExtension_do_opts')
  let ctrlPExtensionObj.get_callback = function('<SNR>' . s:SID() . '_CtrlPExtension_get_callback')
  let ctrlPExtensionObj.new_callback = function('<SNR>' . s:SID() . '_CtrlPExtension_new_callback')
  return ctrlPExtensionObj
endfunction

function! s:CtrlPExtension_next_id() dict
  let self.id_counter = self.id_counter + 1
  return self.id_counter
endfunction

function! s:CtrlPExtension_set_options(options) dict
  let self.options = a:options
endfunction

function! s:CtrlPExtension_get_options() dict
  return self.options
endfunction

function! s:CtrlPExtension_set_name(name) dict
  let self.name = a:name
  if self.enabled
    let opts = self.get_options()
    let opts.sname = a:name
    let opts.lname = a:name
  endif
endfunction

function! s:CtrlPExtension_get_name() dict
  return self.name
endfunction

function! s:CtrlPExtension_set_agent(agent) dict
  let self.agent = a:agent
endfunction

function! s:CtrlPExtension_get_agent() dict
  return self.agent
endfunction

function! s:CtrlPExtension_get_ext_vars() dict
  let opts = self.get_options()
  let opts.sname = self.get_name()
  let opts.lname = self.get_name()
  let opts.init = self.get_callback('init')
  let opts.accept = self.get_callback('accept')
  let opts.enter = self.get_callback('enter')
  let opts.exit = self.get_callback('exit')
  let opts.opts = self.get_callback('opts')
  return opts
endfunction

function! s:CtrlPExtension_get_id() dict
  return self.id
endfunction

function! s:CtrlPExtension_get_ex_cmd_name() dict
  return "CtrlP" . self.name
endfunction

function! s:CtrlPExtension_enable() dict
  if !(exists('g:ctrlp_ext_vars'))
    return
  endif
  let ext_vars = self.get_ext_vars()
  call add(g:ctrlp_ext_vars, ext_vars)
  let self.id = g:ctrlp_builtins + len(g:ctrlp_ext_vars)
  let ex_cmd = "command! " . self.get_ex_cmd_name() . " :call ctrlp#init(" . self.id . ")"
  execute ex_cmd
  let self.enabled = 1
  return ext_vars
endfunction

function! s:CtrlPExtension_disable() dict
  let self.enabled = 0
  if exists(":" . self.get_ex_cmd_name())
    execute ":delcommand " . self.get_ex_cmd_name()
  endif
endfunction

function! s:CtrlPExtension_show() dict
  if !(exists('g:speckle_mode'))
    call ctrlp#init(self.get_id())
  endif
endfunction

function! s:CtrlPExtension_do_init(...) dict
  if !(self.enabled)
    return []
  endif
  let self.inited = 1
  return self.agent.init()
endfunction

function! s:CtrlPExtension_do_accept(mode, str) dict
  if self.inited && !exists('g:speckle_mode')
    call ctrlp#exit()
    let self.inited = 0
  endif
  let result = self.agent.accept(a:mode, a:str)
  return result
endfunction

function! s:CtrlPExtension_do_enter(...) dict
  return self.agent.enter()
endfunction

function! s:CtrlPExtension_do_exit(...) dict
  return self.agent.exit()
endfunction

function! s:CtrlPExtension_do_opts(...) dict
  return self.agent.opts()
endfunction

function! s:CtrlPExtension_get_callback(method) dict
  let callback = self.new_callback(a:method)
  if !(a:method ==# 'accept')
    let callback = callback . "()"
  endif
  return callback
endfunction

function! s:CtrlPExtension_new_callback(method) dict
  let Callback = s:create_delegate(self, "do_" . a:method)
  return s:get_delegate_name(Callback)
endfunction

function! s:has_ctrlp_plugin()
  return exists('g:ctrlp_ext_vars')
endfunction

function! s:CommandRegistryConstructor()
  let commandRegistryObj = {}
  let commandRegistryObj.is_command_registry = 1
  let commandRegistryObj.commands = {}
  let commandRegistryObj.actions = {}
  let commandRegistryObj.id_counter = 0
  let commandRegistryObj.next_command_id = function('<SNR>' . s:SID() . '_CommandRegistry_next_command_id')
  let commandRegistryObj.add = function('<SNR>' . s:SID() . '_CommandRegistry_add')
  let commandRegistryObj.remove = function('<SNR>' . s:SID() . '_CommandRegistry_remove')
  let commandRegistryObj.unregister = function('<SNR>' . s:SID() . '_CommandRegistry_unregister')
  let commandRegistryObj.remove_all = function('<SNR>' . s:SID() . '_CommandRegistry_remove_all')
  let commandRegistryObj.count = function('<SNR>' . s:SID() . '_CommandRegistry_count')
  let commandRegistryObj.auto_register = function('<SNR>' . s:SID() . '_CommandRegistry_auto_register')
  let commandRegistryObj.register = function('<SNR>' . s:SID() . '_CommandRegistry_register')
  let commandRegistryObj.register_ex_commands = function('<SNR>' . s:SID() . '_CommandRegistry_register_ex_commands')
  let commandRegistryObj.register_ctrlp_commands = function('<SNR>' . s:SID() . '_CommandRegistry_register_ctrlp_commands')
  let commandRegistryObj.remove_command = function('<SNR>' . s:SID() . '_CommandRegistry_remove_command')
  let commandRegistryObj.remove_action = function('<SNR>' . s:SID() . '_CommandRegistry_remove_action')
  let commandRegistryObj.unregister_command = function('<SNR>' . s:SID() . '_CommandRegistry_unregister_command')
  let commandRegistryObj.unregister_ctrlp_command = function('<SNR>' . s:SID() . '_CommandRegistry_unregister_ctrlp_command')
  let commandRegistryObj.find = function('<SNR>' . s:SID() . '_CommandRegistry_find')
  let commandRegistryObj.register_ex_command = function('<SNR>' . s:SID() . '_CommandRegistry_register_ex_command')
  let commandRegistryObj.command_has_name = function('<SNR>' . s:SID() . '_CommandRegistry_command_has_name')
  let commandRegistryObj.new_callback = function('<SNR>' . s:SID() . '_CommandRegistry_new_callback')
  let commandRegistryObj.get_callback = function('<SNR>' . s:SID() . '_CommandRegistry_get_callback')
  let commandRegistryObj.get_completer = function('<SNR>' . s:SID() . '_CommandRegistry_get_completer')
  let commandRegistryObj.register_command = function('<SNR>' . s:SID() . '_CommandRegistry_register_command')
  let commandRegistryObj.register_commands = function('<SNR>' . s:SID() . '_CommandRegistry_register_commands')
  let commandRegistryObj.run_command = function('<SNR>' . s:SID() . '_CommandRegistry_run_command')
  let commandRegistryObj.run_action = function('<SNR>' . s:SID() . '_CommandRegistry_run_action')
  let commandRegistryObj.complete_command = function('<SNR>' . s:SID() . '_CommandRegistry_complete_command')
  let commandRegistryObj.is_cmd = function('<SNR>' . s:SID() . '_CommandRegistry_is_cmd')
  let commandRegistryObj.has_bang = function('<SNR>' . s:SID() . '_CommandRegistry_has_bang')
  let commandRegistryObj.has_range = function('<SNR>' . s:SID() . '_CommandRegistry_has_range')
  let commandRegistryObj.has_count = function('<SNR>' . s:SID() . '_CommandRegistry_has_count')
  let commandRegistryObj.get_display_name = function('<SNR>' . s:SID() . '_CommandRegistry_get_display_name')
  let commandRegistryObj.find_by_id = function('<SNR>' . s:SID() . '_CommandRegistry_find_by_id')
  let commandRegistryObj.has_action = function('<SNR>' . s:SID() . '_CommandRegistry_has_action')
  let commandRegistryObj.register_ctrlp_command = function('<SNR>' . s:SID() . '_CommandRegistry_register_ctrlp_command')
  let commandRegistryObj.has_ctrlp = function('<SNR>' . s:SID() . '_CommandRegistry_has_ctrlp')
  let commandRegistryObj.get_ctrlp_extension = function('<SNR>' . s:SID() . '_CommandRegistry_get_ctrlp_extension')
  let commandRegistryObj.get_ctrlp_agent = function('<SNR>' . s:SID() . '_CommandRegistry_get_ctrlp_agent')
  let commandRegistryObj.get_self_callback = function('<SNR>' . s:SID() . '_CommandRegistry_get_self_callback')
  let commandRegistryObj.get_ctrlp_callback = function('<SNR>' . s:SID() . '_CommandRegistry_get_ctrlp_callback')
  let commandRegistryObj.get_ctrlp_repr = function('<SNR>' . s:SID() . '_CommandRegistry_get_ctrlp_repr')
  let commandRegistryObj.unlink = function('<SNR>' . s:SID() . '_CommandRegistry_unlink')
  return commandRegistryObj
endfunction

function! s:CommandRegistry_next_command_id() dict
  let self.id_counter = self.id_counter + 1
  return self.id_counter
endfunction

function! s:CommandRegistry_add(cmd) dict
  let id = self.next_command_id()
  let a:cmd.command_id = id
  let self.commands[id] = a:cmd
  let name = a:cmd.get_name()
  let self.actions[name] = id
  call self.auto_register(a:cmd)
endfunction

function! s:CommandRegistry_remove(cmd) dict
  call self.unregister_command(a:cmd)
  call self.remove_command(a:cmd.get_command_id())
endfunction

function! s:CommandRegistry_unregister() dict
  for cmd in values(self.commands)
    if cmd.has_ex_mode()
      call self.unregister_command(cmd)
    endif
    if cmd.has_ctrlp_mode()
      call self.unregister_ctrlp_command(cmd)
    endif
  endfor
endfunction

function! s:CommandRegistry_remove_all() dict
  for cmd in values(self.commands)
    call self.remove_command(cmd.get_command_id())
    call self.remove_action(cmd.get_name())
  endfor
endfunction

function! s:CommandRegistry_count() dict
  return len(self.commands)
endfunction

function! s:CommandRegistry_auto_register(cmd) dict
  if a:cmd.get_auto_register()
    call self.register(a:cmd)
  endif
endfunction

function! s:CommandRegistry_register(cmd) dict
  if a:cmd.has_ex_mode()
    call self.register_ex_commands(a:cmd)
  endif
  if a:cmd.has_ctrlp_mode()
    call self.register_ctrlp_commands(a:cmd)
  endif
endfunction

function! s:CommandRegistry_register_ex_commands(cmd) dict
  let options = a:cmd.get_options()
  let names = a:cmd.get_names()
  for name in names
    call self.register_ex_command(a:cmd, name, options, self.get_self_callback())
  endfor
  call a:cmd.set_registered(1)
endfunction

function! s:CommandRegistry_register_ctrlp_commands(cmd) dict
  let names = a:cmd.get_ctrlp_names()
  let options = {}
  let options.bang = 1
  let options.bar = 0
  let options.nargs = '0'
  let options.complete = 0
  for name in names
    let name = "CtrlP" . name
    call self.register_ctrlp_command(a:cmd, name, options)
  endfor
endfunction

function! s:CommandRegistry_remove_command(id) dict
  execute ":unlet self.commands[" . a:id . "]"
endfunction

function! s:CommandRegistry_remove_action(name) dict
  execute ":unlet self.actions['" . a:name . "']"
endfunction

function! s:CommandRegistry_unregister_command(cmd) dict
  if a:cmd.has_registered() && a:cmd.get_auto_unregister()
    let names = a:cmd.get_names()
    for name in names
      if exists(":" . name)
        execute ":silent! delcommand " . name
      endif
    endfor
  endif
endfunction

function! s:CommandRegistry_unregister_ctrlp_command(cmd) dict
  if a:cmd.has_registered() && a:cmd.get_auto_unregister()
    let names = a:cmd.get_ctrlp_names()
    for name in names
      let name = "CtrlP" . name
      if exists(":" . name)
        execute ":silent! delcommand " . name
      endif
    endfor
  endif
endfunction

function! s:CommandRegistry_find(cmd_line) dict
  for cmd in values(self.commands)
    let match = self.command_has_name(cmd, a:cmd_line)
    if match.ok
      let match.cmd = cmd
      return match
    endif
  endfor
  return {'ok': 0}
endfunction

function! s:CommandRegistry_register_ex_command(cmd, name, options, Callback) dict
  let builder = s:CommandBuilderConstructor()
  let id = a:cmd.get_command_id()
  if type(a:options.complete) ==# type('string') && a:options.complete ==# 'customlist'
    let a:options.complete = self.get_completer(id, a:name)
  endif
  call builder.options(a:options)
  call builder.name(a:name)
  call builder.repr(self.get_callback(id, a:name, a:Callback))
  let ex_cmd = builder.build()
  execute ex_cmd
endfunction

function! s:CommandRegistry_command_has_name(cmd, cmd_name) dict
  let names = a:cmd.get_names()
  for name in names
    if a:cmd_name =~# "^" . name
      let match = {}
      let match.ok = 1
      let match.name = name
      return match
    endif
  endfor
  return {'ok': 0}
endfunction

function! s:CommandRegistry_new_callback() dict
  let Callback = s:create_delegate(self, 'run_command')
  return Callback
endfunction

function! s:CommandRegistry_get_callback(id, name, Callback) dict
  let callback_name = s:get_delegate_name(a:Callback)
  let opts = "{'bang':'<bang>', 'line1': <line1>, 'line2': <line2>, 'count': <count>})"
  return ":call " . callback_name . "('" . a:id . "', '" . a:name . "', [<f-args>], " . opts
endfunction

function! s:CommandRegistry_get_completer(id, name) dict
  let delegate = s:CompleteDelegateConstructor(self, a:id, a:name)
  let Callback = s:create_delegate(delegate, 'invoke')
  let callback_name = s:get_delegate_name(Callback)
  return "customlist," . callback_name
endfunction

function! s:CommandRegistry_register_command(id) dict
  let cmd = self.find_by_id(a:id)
  if self.is_cmd(cmd)
    call self.register(cmd)
  endif
endfunction

function! s:CommandRegistry_register_commands() dict
  for cmd in values(self.commands)
    call self.register(cmd)
  endfor
endfunction

function! s:CommandRegistry_run_command(id, match, args, options) dict
  let cmd = self.find_by_id(a:id)
  if !(self.is_cmd(cmd))
    call s:echo_warn("Warning: Unable to find command to run for id: " . a:id . ", name: " . a:match)
    return 0
  endif
  let a:options.match = a:match
  let a:options.bang = self.has_bang(a:args, a:options)
  if cmd.get_range() && self.has_range(a:args, a:options)
    let a:options.range = [a:options.line1, a:options.line2]
  endif
  if cmd.get_count()
    if !self.has_count(a:args, a:options)
      let a:options.count = 0
    endif
  else
    if self.has_count(a:args, a:options)
      unlet a:options['count']
    endif
  endif
  let arguments = a:args + [a:options]
  return call(cmd['run'], arguments, cmd)
endfunction

function! s:CommandRegistry_run_action(name, ...) dict
  if !(has_key(self.actions, a:name))
    call s:echo_warn("Warning: Unable to find action for name: " . a:name)
    return 0
  endif
  let n = len(a:000)
  if n >=# 1
    let last_arg = a:000[-1]
    if type(last_arg) ==# type({}) && has_key(last_arg, 'is_option') && last_arg.is_option ==# 1
      let opts = last_arg
      let params = a:000[0 : -2]
    else
      let opts = {}
      let params = a:000
    endif
  else
    let opts = {}
    let params = a:000
  endif
  let id = self.actions[a:name]
  return self.run_command(id, a:name, params, opts)
endfunction

function! s:CommandRegistry_complete_command(id, name, word, cmd_line, cursor) dict
  let cmd = self.find_by_id(a:id)
  if !(self.is_cmd(cmd))
    call s:echo_warn("Warning: Unable to find command to complete for id: " . a:id . ", name: " . match)
    return 0
  endif
  return cmd.complete(a:word, a:cmd_line, a:cursor)
endfunction

function! s:CommandRegistry_is_cmd(cmd) dict
  return type(a:cmd) !=# type(0)
endfunction

function! s:CommandRegistry_has_bang(args, options) dict
  let bang = has_key(a:options, 'bang') && a:options.bang !=# ''
  if !(bang)
    let nargs = len(a:args)
    if nargs ># 0
      let last_arg = a:args[-1]
      if type(last_arg) ==# type('') && last_arg =~# '!$'
        let bang = 1
        let a:args[-1] = strpart(last_arg, 0, len(last_arg) - 1)
      endif
    endif
  endif
  return bang
endfunction

function! s:CommandRegistry_has_range(args, options) dict
  if has_key(a:options, 'line1') && has_key(a:options, 'line2') && has_key(a:options, 'count')
    return a:options.count !=# -1
  else
    return 0
  endif
endfunction

function! s:CommandRegistry_has_count(args, options) dict
  if has_key(a:options, 'line1') && has_key(a:options, 'line2') && has_key(a:options, 'count')
    return a:options.line1 ==# a:options.line2 && a:options.count !=# -1
  else
    return 0
  endif
endfunction

function! s:CommandRegistry_get_display_name(id, name) dict
  let cmd = self.find_by_id(a:id)
  if self.is_cmd(a:id)
    return cmd.get_display_name(a:name)
  endif
  return "UnknownCommand - " . a:name
endfunction

function! s:CommandRegistry_find_by_id(id) dict
  if has_key(self.commands, a:id)
    return self.commands[a:id]
  else
    return 0
  endif
endfunction

function! s:CommandRegistry_has_action(name) dict
  return has_key(self.actions, a:name)
endfunction

function! s:CommandRegistry_register_ctrlp_command(cmd, name, options) dict
  let id = a:cmd.get_command_id()
  let builder = s:CommandBuilderConstructor()
  call builder.options(a:options)
  call builder.name(a:name)
  call builder.repr(self.get_ctrlp_repr(id, a:name))
  let ex_cmd = builder.build()
  execute ex_cmd
endfunction

function! s:CommandRegistry_has_ctrlp() dict
  return exists('g:ctrlp_ext_vars')
endfunction

function! s:CommandRegistry_get_ctrlp_extension() dict
  if !(has_key(self, 'ctrlp_extension'))
    let agent = self.get_ctrlp_agent()
    let self.ctrlp_options = {}
    let self.ctrlp_extension = s:CtrlPExtensionConstructor()
    call self.ctrlp_extension.set_name('Portkey')
    call self.ctrlp_extension.set_agent(agent)
    call self.ctrlp_extension.set_options(self.ctrlp_options)
    call self.ctrlp_extension.enable()
  endif
  return self.ctrlp_extension
endfunction

function! s:CommandRegistry_get_ctrlp_agent() dict
  if !(has_key(self, 'ctrlp_agent'))
    let self.ctrlp_agent = s:CtrlPAgentConstructor(self)
  endif
  return self.ctrlp_agent
endfunction

function! s:CommandRegistry_get_self_callback() dict
  if !(has_key(self, 'Callback'))
    let self.Callback = self.new_callback()
  endif
  return self.Callback
endfunction

function! s:CommandRegistry_get_ctrlp_callback() dict
  if !(has_key(self, 'CtrlPCallback'))
    let delegate = s:CtrlPDelegateConstructor(self.get_ctrlp_extension(), self)
    let self.CtrlPCallback = s:create_delegate(delegate, 'invoke')
  endif
  return self.CtrlPCallback
endfunction

function! s:CommandRegistry_get_ctrlp_repr(id, name) dict
  let Callback = self.get_ctrlp_callback()
  let callback_name = s:get_delegate_name(Callback)
  let opts = "{'bang': '<bang>'}"
  return ":call " . callback_name . "('" . a:id . "', '" . a:name . "', " . opts . ")"
endfunction

function! s:CommandRegistry_unlink() dict
  let Callback = self.get_self_callback()
  call s:unlink_delegate(Callback)
  unlet self.Callback
  let CtrlPCallback = self.get_ctrlp_callback()
  call s:unlink_delegate(CtrlPCallback)
  unlet self.CtrlPCallback
endfunction

function! s:CompleteDelegateConstructor(registry, id, name)
  let completeDelegateObj = {}
  let completeDelegateObj.registry = a:registry
  let completeDelegateObj.id = a:id
  let completeDelegateObj.name = a:name
  let completeDelegateObj.invoke = function('<SNR>' . s:SID() . '_CompleteDelegate_invoke')
  return completeDelegateObj
endfunction

function! s:CompleteDelegate_invoke(word, cmd_line, cursor) dict
  return self.registry.complete_command(self.id, self.name, a:word, a:cmd_line, a:cursor)
endfunction

function! s:CtrlPDelegateConstructor(extension, registry)
  let ctrlPDelegateObj = {}
  let ctrlPDelegateObj.extension = a:extension
  let ctrlPDelegateObj.registry = a:registry
  let ctrlPDelegateObj.invoke = function('<SNR>' . s:SID() . '_CtrlPDelegate_invoke')
  return ctrlPDelegateObj
endfunction

function! s:CtrlPDelegate_invoke(id, name, ex_opts) dict
  let agent = self.extension.get_agent()
  call agent.set_command(a:id, a:name)
  call agent.set_ex_opts(a:ex_opts)
  call self.extension.set_name(self.registry.get_display_name(a:id, a:name))
  call self.extension.show()
endfunction

function! s:CtrlPAgentConstructor(registry)
  let ctrlPAgentObj = {}
  let ctrlPAgentObj.registry = a:registry
  let ctrlPAgentObj.init = function('<SNR>' . s:SID() . '_CtrlPAgent_init')
  let ctrlPAgentObj.accept = function('<SNR>' . s:SID() . '_CtrlPAgent_accept')
  let ctrlPAgentObj.enter = function('<SNR>' . s:SID() . '_CtrlPAgent_enter')
  let ctrlPAgentObj.exit = function('<SNR>' . s:SID() . '_CtrlPAgent_exit')
  let ctrlPAgentObj.opts = function('<SNR>' . s:SID() . '_CtrlPAgent_opts')
  let ctrlPAgentObj.set_command = function('<SNR>' . s:SID() . '_CtrlPAgent_set_command')
  let ctrlPAgentObj.set_ex_opts = function('<SNR>' . s:SID() . '_CtrlPAgent_set_ex_opts')
  let ctrlPAgentObj.has_bang = function('<SNR>' . s:SID() . '_CtrlPAgent_has_bang')
  let ctrlPAgentObj.has_command = function('<SNR>' . s:SID() . '_CtrlPAgent_has_command')
  let ctrlPAgentObj.get_cmd_line = function('<SNR>' . s:SID() . '_CtrlPAgent_get_cmd_line')
  return ctrlPAgentObj
endfunction

function! s:CtrlPAgent_init() dict
  return self.registry.complete_command(self.command_id, self.resource_type, '', self.get_cmd_line(), 0)
endfunction

function! s:CtrlPAgent_accept(mode, str) dict
  let opts = {}
  let opts.mode = a:mode
  let opts.bang = self.has_bang()
  return self.registry.run_command(self.command_id, self.resource_type, [a:str], opts)
endfunction

function! s:CtrlPAgent_enter() dict
endfunction

function! s:CtrlPAgent_exit() dict
endfunction

function! s:CtrlPAgent_opts() dict
endfunction

function! s:CtrlPAgent_set_command(id, name) dict
  let self.command_id = a:id
  let self.resource_type = a:name
endfunction

function! s:CtrlPAgent_set_ex_opts(ex_opts) dict
  let self.ex_opts = a:ex_opts
endfunction

function! s:CtrlPAgent_has_bang() dict
  return has_key(self.ex_opts, 'bang') && self.ex_opts.bang ==# '!'
endfunction

function! s:CtrlPAgent_has_command() dict
  return has_key(self, 'command_id')
endfunction

function! s:CtrlPAgent_get_cmd_line() dict
  let cmd_line = self.resource_type
  if self.has_bang()
    let cmd_line .= '!'
  endif
  return cmd_line
endfunction

" included: 'wpcli.riml'
" included: 'json_parser.riml'
function! s:JSONParserConstructor()
  let jSONParserObj = {}
  let jSONParserObj.parse = function('<SNR>' . s:SID() . '_JSONParser_parse')
  let jSONParserObj.clean = function('<SNR>' . s:SID() . '_JSONParser_clean')
  return jSONParserObj
endfunction

function! s:JSONParser_parse(str) dict
  try
    let text = self.clean(a:str)
    if has('python')
      let result = pyeval(text)
    else
      let result = eval(a:str)
    endif
    return result
  catch /.*/
    return 0
  endtry
endfunction

function! s:JSONParser_clean(text) dict
  let cleaned = substitute(a:text, ':true', ':1', 'g')
  let cleaned = substitute(cleaned, ':false', ':0', 'g')
  let cleaned = substitute(cleaned, ':null', ':""', 'g')
  return cleaned
endfunction

function! s:WpCliConstructor()
  let wpCliObj = {}
  let wpCliObj.is_wpcli = 1
  let wpCliObj.path = 'wp'
  let wpCliObj.env_vars = {}
  let wpCliObj.env_vars['SHELL_PIPE'] = 0
  let wpCliObj.set_path = function('<SNR>' . s:SID() . '_WpCli_set_path')
  let wpCliObj.get_path = function('<SNR>' . s:SID() . '_WpCli_get_path')
  let wpCliObj.add_env_var = function('<SNR>' . s:SID() . '_WpCli_add_env_var')
  let wpCliObj.remove_env_var = function('<SNR>' . s:SID() . '_WpCli_remove_env_var')
  let wpCliObj.get_env_vars = function('<SNR>' . s:SID() . '_WpCli_get_env_vars')
  let wpCliObj.build = function('<SNR>' . s:SID() . '_WpCli_build')
  let wpCliObj.exec = function('<SNR>' . s:SID() . '_WpCli_exec')
  let wpCliObj.parse = function('<SNR>' . s:SID() . '_WpCli_parse')
  let wpCliObj.get_parser = function('<SNR>' . s:SID() . '_WpCli_get_parser')
  let wpCliObj.run = function('<SNR>' . s:SID() . '_WpCli_run')
  let wpCliObj.dump = function('<SNR>' . s:SID() . '_WpCli_dump')
  let wpCliObj.list = function('<SNR>' . s:SID() . '_WpCli_list')
  return wpCliObj
endfunction

function! s:WpCli_set_path(path) dict
  let self.path = a:path
endfunction

function! s:WpCli_get_path() dict
  return self.path
endfunction

function! s:WpCli_add_env_var(key, value) dict
  let self.env_vars[a:key] = a:value
endfunction

function! s:WpCli_remove_env_var(key) dict
  unlet self.env_vars[a:key]
endfunction

function! s:WpCli_get_env_vars() dict
  let vars = ''
  for var in keys(self.env_vars)
    let vars .= var . "=" . self.env_vars[var] . " "
  endfor
  return vars
endfunction

function! s:WpCli_build(args) dict
  let env = self.get_env_vars()
  let cmd_args = join(a:args, ' ')
  let cmd = env . " " . self.path . " " . cmd_args
  return cmd
endfunction

function! s:WpCli_exec(args) dict
  let cmd = self.build(a:args)
  let result = system(cmd)
  if result[0] ==# '{'
    return self.parse(result)
  else
    return result
  endif
endfunction

function! s:WpCli_parse(text) dict
  return self.get_parser().parse(a:text)
endfunction

function! s:WpCli_get_parser() dict
  if !(has_key(self, 'parser'))
    let self.parser = s:JSONParserConstructor()
  endif
  return self.parser
endfunction

function! s:WpCli_run(...) dict
  return self.exec(a:000)
endfunction

function! s:WpCli_dump() dict
  return self.run('cli', 'cmd-dump', '--format=json')
endfunction

function! s:WpCli_list() dict
  let meta = self.dump()
  let cmds = []
  if type(meta) ==# type({})
    if has_key(meta, 'subcommands')
      for cmd in meta.subcommands
        call add(cmds, cmd.name)
      endfor
    endif
  endif
  return cmds
endfunction

" included: 'wordpress_path.riml'
function! s:WordPressPathConstructor()
  let wordPressPathObj = {}
  let wordPressPathObj.needs = function('<SNR>' . s:SID() . '_WordPressPath_needs')
  let wordPressPathObj.get_path = function('<SNR>' . s:SID() . '_WordPressPath_get_path')
  let wordPressPathObj.get_detectors = function('<SNR>' . s:SID() . '_WordPressPath_get_detectors')
  let wordPressPathObj.find_wp_cli_project_path = function('<SNR>' . s:SID() . '_WordPressPath_find_wp_cli_project_path')
  let wordPressPathObj.to_abs_path = function('<SNR>' . s:SID() . '_WordPressPath_to_abs_path')
  let wordPressPathObj.calc_abs_path = function('<SNR>' . s:SID() . '_WordPressPath_calc_abs_path')
  return wordPressPathObj
endfunction

function! s:WordPressPath_needs() dict
  return ['wpcli_config', 'with_dir']
endfunction

function! s:WordPressPath_get_path(root) dict
  for detector in self.get_detectors()
    let result = detector.detect(a:root)
    let type = detector.get_type()
    if result.status && type ==# 'core'
      return result.path
    elseif result.status && type ==# 'wpcli'
      return self.find_wp_cli_project_path(a:root)
    endif
  endfor
  let path = self.find_wp_cli_project_path(a:root)
  if path ==# ''
    if exists('g:wordpress_vim_wordpress_path')
      let path = g:wordpress_vim_wordpress_path
    else
      call s:echo_error('WordPress not detected, Please set g:wordpress_vim_wordpress_path in your vimrc')
    endif
  endif
  return path
endfunction

function! s:WordPressPath_get_detectors() dict
  let detectors = []
  call add(detectors, s:CoreDetectorConstructor())
  call add(detectors, s:WpCliDetectorConstructor())
  return detectors
endfunction

function! s:WordPressPath_find_wp_cli_project_path(root) dict
  let config = self.container.lookup('wpcli_config')
  let config_path = config.get_config_path(a:root)
  let config_parent = fnamemodify(config_path, ':h')
  call config.load(a:root)
  let project_path = config.get_config_param('path')
  if project_path !=# ''
    return self.to_abs_path(project_path, config_parent)
  else
    return ''
  endif
endfunction

function! s:WordPressPath_to_abs_path(project_path, parent_dir) dict
  let with_dir = self.container.lookup('with_dir')
  call with_dir.set_dir(a:parent_dir)
  return with_dir.run(self, 'calc_abs_path', [a:project_path])
endfunction

function! s:WordPressPath_calc_abs_path(project_path) dict
  let path = fnamemodify(a:project_path, ':p')
  let path = substitute(path, '/$', '', '')
  return path
endfunction

" included: 'wpcli_command_factory.riml'
" included: 'wordpress_command.riml'
" included: 'base_command.riml'
function! s:BaseCommandConstructor()
  let baseCommandObj = {}
  let baseCommandObj.get_command_id = function('<SNR>' . s:SID() . '_BaseCommand_get_command_id')
  let baseCommandObj.get_auto_register = function('<SNR>' . s:SID() . '_BaseCommand_get_auto_register')
  let baseCommandObj.get_auto_unregister = function('<SNR>' . s:SID() . '_BaseCommand_get_auto_unregister')
  let baseCommandObj.has_ex_mode = function('<SNR>' . s:SID() . '_BaseCommand_has_ex_mode')
  let baseCommandObj.has_ctrlp_mode = function('<SNR>' . s:SID() . '_BaseCommand_has_ctrlp_mode')
  let baseCommandObj.set_registered = function('<SNR>' . s:SID() . '_BaseCommand_set_registered')
  let baseCommandObj.has_registered = function('<SNR>' . s:SID() . '_BaseCommand_has_registered')
  let baseCommandObj.get_name = function('<SNR>' . s:SID() . '_BaseCommand_get_name')
  let baseCommandObj.get_aliases = function('<SNR>' . s:SID() . '_BaseCommand_get_aliases')
  let baseCommandObj.get_names = function('<SNR>' . s:SID() . '_BaseCommand_get_names')
  let baseCommandObj.get_ctrlp_aliases = function('<SNR>' . s:SID() . '_BaseCommand_get_ctrlp_aliases')
  let baseCommandObj.get_ctrlp_names = function('<SNR>' . s:SID() . '_BaseCommand_get_ctrlp_names')
  let baseCommandObj.get_display_name = function('<SNR>' . s:SID() . '_BaseCommand_get_display_name')
  let baseCommandObj.get_bang = function('<SNR>' . s:SID() . '_BaseCommand_get_bang')
  let baseCommandObj.get_bar = function('<SNR>' . s:SID() . '_BaseCommand_get_bar')
  let baseCommandObj.get_nargs = function('<SNR>' . s:SID() . '_BaseCommand_get_nargs')
  let baseCommandObj.get_buffer = function('<SNR>' . s:SID() . '_BaseCommand_get_buffer')
  let baseCommandObj.get_register = function('<SNR>' . s:SID() . '_BaseCommand_get_register')
  let baseCommandObj.get_completer = function('<SNR>' . s:SID() . '_BaseCommand_get_completer')
  let baseCommandObj.get_range = function('<SNR>' . s:SID() . '_BaseCommand_get_range')
  let baseCommandObj.get_count = function('<SNR>' . s:SID() . '_BaseCommand_get_count')
  let baseCommandObj.get_options = function('<SNR>' . s:SID() . '_BaseCommand_get_options')
  let baseCommandObj.complete = function('<SNR>' . s:SID() . '_BaseCommand_complete')
  let baseCommandObj.run = function('<SNR>' . s:SID() . '_BaseCommand_run')
  return baseCommandObj
endfunction

function! s:BaseCommand_get_command_id() dict
  return self.command_id
endfunction

function! s:BaseCommand_get_auto_register() dict
  return 0
endfunction

function! s:BaseCommand_get_auto_unregister() dict
  return 1
endfunction

function! s:BaseCommand_has_ex_mode() dict
  return 0
endfunction

function! s:BaseCommand_has_ctrlp_mode() dict
  return 0
endfunction

function! s:BaseCommand_set_registered(registered) dict
  let self.registered = a:registered
endfunction

function! s:BaseCommand_has_registered() dict
  return has_key(self, 'registered') && self.registered
endfunction

function! s:BaseCommand_get_name() dict
  return 'BaseCommand'
endfunction

function! s:BaseCommand_get_aliases() dict
  return []
endfunction

function! s:BaseCommand_get_names() dict
  return [self.get_name()] + self.get_aliases()
endfunction

function! s:BaseCommand_get_ctrlp_aliases() dict
  return self.get_aliases()
endfunction

function! s:BaseCommand_get_ctrlp_names() dict
  return self.get_ctrlp_aliases()
endfunction

function! s:BaseCommand_get_display_name(cmd_name) dict
  return substitute(a:cmd_name, 'CtrlP', '', '')
endfunction

function! s:BaseCommand_get_bang() dict
  return 1
endfunction

function! s:BaseCommand_get_bar() dict
  return 1
endfunction

function! s:BaseCommand_get_nargs() dict
  return '*'
endfunction

function! s:BaseCommand_get_buffer() dict
  return 1
endfunction

function! s:BaseCommand_get_register() dict
  return 0
endfunction

function! s:BaseCommand_get_completer() dict
  return 0
endfunction

function! s:BaseCommand_get_range() dict
  return 0
endfunction

function! s:BaseCommand_get_count() dict
  return 0
endfunction

function! s:BaseCommand_get_options() dict
  let opts = {}
  let opts.bang = self.get_bang()
  let opts.bar = self.get_bar()
  let opts.nargs = self.get_nargs()
  let opts.buffer = self.get_buffer()
  let opts.register = self.get_register()
  let opts.complete = self.get_completer()
  let opts.range = self.get_range()
  let opts.count = self.get_count()
  return opts
endfunction

function! s:BaseCommand_complete(word, cmd_line, cursor) dict
  return []
endfunction

function! s:BaseCommand_run(...) dict
endfunction

function! s:WordPressCommandConstructor(container)
  let wordPressCommandObj = {}
  let baseCommandObj = s:BaseCommandConstructor()
  call extend(wordPressCommandObj, baseCommandObj)
  let wordPressCommandObj.container = a:container
  let wordPressCommandObj.lookup = function('<SNR>' . s:SID() . '_WordPressCommand_lookup')
  let wordPressCommandObj.process = function('<SNR>' . s:SID() . '_WordPressCommand_process')
  let wordPressCommandObj.current_buffer = function('<SNR>' . s:SID() . '_WordPressCommand_current_buffer')
  let wordPressCommandObj.current_buffer_full_path = function('<SNR>' . s:SID() . '_WordPressCommand_current_buffer_full_path')
  let wordPressCommandObj.current_buffer_project_path = function('<SNR>' . s:SID() . '_WordPressCommand_current_buffer_project_path')
  let wordPressCommandObj.current_project = function('<SNR>' . s:SID() . '_WordPressCommand_current_project')
  let wordPressCommandObj.expand_args = function('<SNR>' . s:SID() . '_WordPressCommand_expand_args')
  let wordPressCommandObj.get_current_word = function('<SNR>' . s:SID() . '_WordPressCommand_get_current_word')
  let wordPressCommandObj.get_selected_text = function('<SNR>' . s:SID() . '_WordPressCommand_get_selected_text')
  let wordPressCommandObj.get_current_line = function('<SNR>' . s:SID() . '_WordPressCommand_get_current_line')
  let wordPressCommandObj.is_false = function('<SNR>' . s:SID() . '_WordPressCommand_is_false')
  let wordPressCommandObj.is_true = function('<SNR>' . s:SID() . '_WordPressCommand_is_true')
  return wordPressCommandObj
endfunction

function! s:WordPressCommand_lookup(key) dict
  return self.container.lookup(a:key)
endfunction

function! s:WordPressCommand_process(...) dict
  let registry = self.lookup('registry')
  return call(registry['run_action'], a:000, registry)
endfunction

function! s:WordPressCommand_current_buffer() dict
  return self.lookup('buffer_collection').get_current()
endfunction

function! s:WordPressCommand_current_buffer_full_path() dict
  return self.current_buffer().get_full_path()
endfunction

function! s:WordPressCommand_current_buffer_project_path() dict
  return self.current_buffer().get_project_path()
endfunction

function! s:WordPressCommand_current_project() dict
  return self.lookup('project_collection').project_for(self.current_buffer_project_path())
endfunction

function! s:WordPressCommand_expand_args(args) dict
  let n = len(a:args)
  let opts = a:args[n - 1]
  let params = a:args[0 : -2]
  return [params, opts]
endfunction

function! s:WordPressCommand_get_current_word(params, opts) dict
  if len(a:params) ># 0
    let word = join(a:params, ' ')
  elseif has_key(a:opts, 'range')
    let word = self.get_selected_text()
  else
    let word = expand("<cword>")
  endif
  return word
endfunction

function! s:WordPressCommand_get_selected_text() dict
  let [lnum1, col1] = getpos("'<")[1 : 2]
  let [lnum2, col2] = getpos("'>")[1 : 2]
  let lines = getline(lnum1, lnum2)
  let lines[-1] = lines[-1][: col2 - (&selection ==# 'inclusive' ? 1 : 2)]
  let lines[0] = lines[0][col1 - 1 :]
  return join(lines, "\n")
endfunction

function! s:WordPressCommand_get_current_line() dict
  return getline(line('.'))
endfunction

function! s:WordPressCommand_is_false(value) dict
  return type(a:value) ==# type(0) && a:value ==# 0
endfunction

function! s:WordPressCommand_is_true(value) dict
  return type(a:value) ==# type(0) && a:value ==# 1
endfunction

" included: 'wpcli_command.riml'
" included: 'wordpress_project_command.riml'
function! s:WordPressProjectCommandConstructor(container)
  let wordPressProjectCommandObj = {}
  let wordPressCommandObj = s:WordPressCommandConstructor(a:container)
  call extend(wordPressProjectCommandObj, wordPressCommandObj)
  let wordPressProjectCommandObj.lookup = function('<SNR>' . s:SID() . '_WordPressProjectCommand_lookup')
  return wordPressProjectCommandObj
endfunction

function! s:WordPressProjectCommand_lookup(key) dict
  let buffer_collection = self.container.lookup('buffer_collection')
  let project_collection = self.container.lookup('project_collection')
  let current_buffer = buffer_collection.get_current()
  let project_path = current_buffer.get_project_path()
  let project = project_collection.project_for(project_path)
  return project.lookup(a:key)
endfunction

function! s:WpCliCommandConstructor(container)
  let wpCliCommandObj = {}
  let wordPressProjectCommandObj = s:WordPressProjectCommandConstructor(a:container)
  call extend(wpCliCommandObj, wordPressProjectCommandObj)
  let wpCliCommandObj.is_wpcli_command = 1
  let wpCliCommandObj.get_auto_register = function('<SNR>' . s:SID() . '_WpCliCommand_get_auto_register')
  let wpCliCommandObj.has_ex_mode = function('<SNR>' . s:SID() . '_WpCliCommand_has_ex_mode')
  let wpCliCommandObj.get_completer = function('<SNR>' . s:SID() . '_WpCliCommand_get_completer')
  let wpCliCommandObj.get_name = function('<SNR>' . s:SID() . '_WpCliCommand_get_name')
  let wpCliCommandObj.set_cmd_name = function('<SNR>' . s:SID() . '_WpCliCommand_set_cmd_name')
  let wpCliCommandObj.get_cmd_name = function('<SNR>' . s:SID() . '_WpCliCommand_get_cmd_name')
  let wpCliCommandObj.complete = function('<SNR>' . s:SID() . '_WpCliCommand_complete')
  let wpCliCommandObj.run = function('<SNR>' . s:SID() . '_WpCliCommand_run')
  let wpCliCommandObj.get_with_dir = function('<SNR>' . s:SID() . '_WpCliCommand_get_with_dir')
  let wpCliCommandObj.do_run = function('<SNR>' . s:SID() . '_WpCliCommand_do_run')
  let wpCliCommandObj.do_complete = function('<SNR>' . s:SID() . '_WpCliCommand_do_complete')
  let wpCliCommandObj.has_hyphen = function('<SNR>' . s:SID() . '_WpCliCommand_has_hyphen')
  let wpCliCommandObj.get_dehyphenated_name = function('<SNR>' . s:SID() . '_WpCliCommand_get_dehyphenated_name')
  let wpCliCommandObj.get_dehyphenated_cmd_line = function('<SNR>' . s:SID() . '_WpCliCommand_get_dehyphenated_cmd_line')
  return wpCliCommandObj
endfunction

function! s:WpCliCommand_get_auto_register() dict
  return 0
endfunction

function! s:WpCliCommand_has_ex_mode() dict
  return 1
endfunction

function! s:WpCliCommand_get_completer() dict
  return 'customlist'
endfunction

function! s:WpCliCommand_get_name() dict
  if self.has_hyphen()
    return "W" . self.get_dehyphenated_name()
  else
    return "W" . self.get_cmd_name()
  endif
endfunction

function! s:WpCliCommand_set_cmd_name(cmd_name) dict
  let self.cmd_name = a:cmd_name
endfunction

function! s:WpCliCommand_get_cmd_name() dict
  return self.cmd_name
endfunction

function! s:WpCliCommand_complete(word, cmd_line, cursor) dict
  let line = a:cmd_line
  let point = a:cursor
  if self.has_hyphen()
    let line = self.get_dehyphenated_cmd_line(a:cmd_line)
    let point = a:cursor + 1
  endif
  return self.do_complete(a:word, line, point)
endfunction

function! s:WpCliCommand_run(...) dict
  let [params, opts] = self.expand_args(a:000)
  return self.do_run(params, opts)
endfunction

function! s:WpCliCommand_get_with_dir() dict
  let with_dir = self.lookup('with_dir')
  call with_dir.set_dir(self.current_buffer_project_path())
  return with_dir
endfunction

function! s:WpCliCommand_do_run(params, opts) dict
  let runner = self.lookup('wpcli_runner')
  let with_dir = self.get_with_dir()
  return with_dir.run(runner, 'run', [self.get_cmd_name(), a:params, a:opts])
endfunction

function! s:WpCliCommand_do_complete(word, line, point) dict
  let completer = self.lookup('wpcli_completer')
  let with_dir = self.get_with_dir()
  return with_dir.run(completer, 'complete', [self.get_cmd_name(), a:word, a:line, a:point])
endfunction

function! s:WpCliCommand_has_hyphen() dict
  return self.get_cmd_name() =~# '-'
endfunction

function! s:WpCliCommand_get_dehyphenated_name() dict
  return substitute(self.get_cmd_name(), '\V-', '', 'g')
endfunction

function! s:WpCliCommand_get_dehyphenated_cmd_line(cmd_line) dict
  return substitute(a:cmd_line, "\\V" . self.get_dehyphenated_name(), self.get_cmd_name(), '')
endfunction

" included: 'eval_file_command.riml'
function! s:EvalFileCommandConstructor(container)
  let evalFileCommandObj = {}
  let wpCliCommandObj = s:WpCliCommandConstructor(a:container)
  call extend(evalFileCommandObj, wpCliCommandObj)
  let evalFileCommandObj.is_eval_file_command = 1
  let evalFileCommandObj.run = function('<SNR>' . s:SID() . '_EvalFileCommand_run')
  return evalFileCommandObj
endfunction

function! s:EvalFileCommand_run(...) dict
  let [params, opts] = self.expand_args(a:000)
  if len(params) ==# 0
    call add(params, self.current_buffer_full_path())
  endif
  return self.do_run(params, opts)
endfunction

" included: 'eval_command.riml'
function! s:EvalCommandConstructor(container)
  let evalCommandObj = {}
  let wpCliCommandObj = s:WpCliCommandConstructor(a:container)
  call extend(evalCommandObj, wpCliCommandObj)
  let evalCommandObj.is_eval_command = 1
  let evalCommandObj.get_range = function('<SNR>' . s:SID() . '_EvalCommand_get_range')
  let evalCommandObj.run = function('<SNR>' . s:SID() . '_EvalCommand_run')
  let evalCommandObj.to_eval_text = function('<SNR>' . s:SID() . '_EvalCommand_to_eval_text')
  return evalCommandObj
endfunction

function! s:EvalCommand_get_range() dict
  return 1
endfunction

function! s:EvalCommand_run(...) dict
  let [params, opts] = self.expand_args(a:000)
  if len(params) ># 0
    let params = self.to_eval_text(params)
  elseif has_key(opts, 'range')
    let params = self.to_eval_text(getline(opts.line1, opts.line2))
  endif
  return self.do_run(params, opts)
endfunction

function! s:EvalCommand_to_eval_text(params) dict
  let text = join(a:params, ' ')
  return [shellescape(text)]
endfunction

" included: 'post_command.riml'
" included: 'autocmd_loader.riml'
function! s:AutocmdLoaderConstructor()
  let autocmdLoaderObj = {}
  let autocmdLoaderObj.cmds = []
  let autocmdLoaderObj.set_group_name = function('<SNR>' . s:SID() . '_AutocmdLoader_set_group_name')
  let autocmdLoaderObj.get_group_name = function('<SNR>' . s:SID() . '_AutocmdLoader_get_group_name')
  let autocmdLoaderObj.load = function('<SNR>' . s:SID() . '_AutocmdLoader_load')
  let autocmdLoaderObj.unload = function('<SNR>' . s:SID() . '_AutocmdLoader_unload')
  let autocmdLoaderObj.cmd = function('<SNR>' . s:SID() . '_AutocmdLoader_cmd')
  let autocmdLoaderObj.size = function('<SNR>' . s:SID() . '_AutocmdLoader_size')
  return autocmdLoaderObj
endfunction

function! s:AutocmdLoader_set_group_name(group_name) dict
  let self.group_name = a:group_name
endfunction

function! s:AutocmdLoader_get_group_name() dict
  return self.group_name
endfunction

function! s:AutocmdLoader_load() dict
  execute ":augroup " . self.get_group_name()
  execute ":autocmd!"
  for cmd in self.cmds
    execute ":autocmd " . cmd
  endfor
  execute ":augroup END"
endfunction

function! s:AutocmdLoader_unload() dict
  execute ":augroup " . self.group_name
  execute ":autocmd!"
  execute ":augroup END"
endfunction

function! s:AutocmdLoader_cmd(ex_cmd) dict
  call add(self.cmds, a:ex_cmd)
endfunction

function! s:AutocmdLoader_size() dict
  return len(self.cmds)
endfunction

" included: 'post_saver.riml'
function! s:PostSaverConstructor()
  let postSaverObj = {}
  let postSaverObj.post_id = '0'
  let postSaverObj.params = []
  let postSaverObj.needs = function('<SNR>' . s:SID() . '_PostSaver_needs')
  let postSaverObj.set_post_id = function('<SNR>' . s:SID() . '_PostSaver_set_post_id')
  let postSaverObj.get_post_id = function('<SNR>' . s:SID() . '_PostSaver_get_post_id')
  let postSaverObj.watch = function('<SNR>' . s:SID() . '_PostSaver_watch')
  let postSaverObj.before_file_save = function('<SNR>' . s:SID() . '_PostSaver_before_file_save')
  let postSaverObj.after_file_save = function('<SNR>' . s:SID() . '_PostSaver_after_file_save')
  let postSaverObj.load_current_buffer = function('<SNR>' . s:SID() . '_PostSaver_load_current_buffer')
  let postSaverObj.post_exists = function('<SNR>' . s:SID() . '_PostSaver_post_exists')
  let postSaverObj.message_for = function('<SNR>' . s:SID() . '_PostSaver_message_for')
  return postSaverObj
endfunction

function! s:PostSaver_needs() dict
  return ['post', 'wpcli_printer']
endfunction

function! s:PostSaver_set_post_id(post_id) dict
  let self.post_id = a:post_id
endfunction

function! s:PostSaver_get_post_id() dict
  return self.post_id
endfunction

function! s:PostSaver_watch(path, params) dict
  let self.params = a:params
  let loader = s:AutocmdLoaderConstructor()
  call loader.set_group_name('wordpress_vim_post_buffer')
  call loader.cmd("BufWritePre " . a:path . " call " . s:new_delegate(self, 'before_file_save') . "()")
  call loader.cmd("BufWritePost " . a:path . " call " . s:new_delegate(self, 'after_file_save') . "()")
  call loader.load()
endfunction

function! s:PostSaver_before_file_save() dict
  let self.modified = &mod
endfunction

function! s:PostSaver_after_file_save() dict
  if !(self.modified)
    return
  endif
  let post_content = self.load_current_buffer()
  if self.post_exists()
    let result = self.post.update(self.post_id, post_content, self.params)
  else
    let self.post_id = self.post.create(post_content, self.params)
    let result = self.message_for(self.post_id)
  endif
  call self.wpcli_printer.print('post', result)
  return result
endfunction

function! s:PostSaver_load_current_buffer() dict
  return join(getline(1, '$'), "\n")
endfunction

function! s:PostSaver_post_exists() dict
  return self.post_id !=# '0'
endfunction

function! s:PostSaver_message_for(post_id) dict
  if a:post_id !=# '0'
    return "Success: Created post " . a:post_id . "."
  else
    return "Error: Failed to create post."
  endif
endfunction

function! s:PostCommandConstructor(container)
  let postCommandObj = {}
  let wpCliCommandObj = s:WpCliCommandConstructor(a:container)
  call extend(postCommandObj, wpCliCommandObj)
  let postCommandObj.is_post_command = 1
  let postCommandObj.run = function('<SNR>' . s:SID() . '_PostCommand_run')
  let postCommandObj.load_post_into = function('<SNR>' . s:SID() . '_PostCommand_load_post_into')
  let postCommandObj.get_temp_file = function('<SNR>' . s:SID() . '_PostCommand_get_temp_file')
  let postCommandObj.open_temp_buffer = function('<SNR>' . s:SID() . '_PostCommand_open_temp_buffer')
  let postCommandObj.get_post_options = function('<SNR>' . s:SID() . '_PostCommand_get_post_options')
  return postCommandObj
endfunction

function! s:PostCommand_run(...) dict
  let [params, opts] = self.expand_args(a:000)
  let post_options = self.get_post_options(params, opts)
  let action = post_options.action
  let post_params = post_options.options
  let temp_file = self.get_temp_file()
  if action ==# 'create'
    let post_id = '0'
  elseif action ==# 'edit'
    let post_id = remove(post_params, 0)
    call self.load_post_into(post_id, temp_file)
  endif
  if (action ==# 'create' || action ==# 'edit') && !opts.bang
    call self.open_temp_buffer(temp_file)
    let post_saver = self.lookup('post_saver')
    call post_saver.set_post_id(post_id)
    call post_saver.watch(temp_file, post_params)
  else
    call self.do_run(params, opts)
  endif
endfunction

function! s:PostCommand_load_post_into(post_id, path) dict
  let post = self.lookup('post')
  let post_content = post.find(a:post_id)
  if post_content !=# ''
    let lines = split(post_content, "\n")
    call writefile(lines, a:path)
  endif
endfunction

function! s:PostCommand_get_temp_file() dict
  return tempname()
endfunction

function! s:PostCommand_open_temp_buffer(path) dict
  if &hidden
    execute ":edit " . a:path
  else
    execute ":tabedit " . a:path
  endif
endfunction

function! s:PostCommand_get_post_options(params, opts) dict
  let post_options = s:PostOptionsConstructor()
  return post_options.parse(a:params, a:opts)
endfunction

function! s:PostOptionsConstructor()
  let postOptionsObj = {}
  let postOptionsObj.parse = function('<SNR>' . s:SID() . '_PostOptions_parse')
  let postOptionsObj.parse_params = function('<SNR>' . s:SID() . '_PostOptions_parse_params')
  return postOptionsObj
endfunction

function! s:PostOptions_parse(params, opts) dict
  let total_params = len(a:params)
  if (total_params ># 0)
    return self.parse_params(a:params, a:opts)
  else
    return {'action': 'help', 'options': []}
  endif
endfunction

function! s:PostOptions_parse_params(params, opts) dict
  let post_params = a:params[0 :]
  let action = remove(post_params, 0)
  let result = {}
  let result.action = action
  let result.options = post_params
  return result
endfunction

" included: 'scaffold_command.riml'
function! s:ScaffoldCommandConstructor(container)
  let scaffoldCommandObj = {}
  let wpCliCommandObj = s:WpCliCommandConstructor(a:container)
  call extend(scaffoldCommandObj, wpCliCommandObj)
  let scaffoldCommandObj.is_scaffold_command = 1
  let scaffoldCommandObj.do_run = function('<SNR>' . s:SID() . '_ScaffoldCommand_do_run')
  let scaffoldCommandObj.get_underscore_theme_file = function('<SNR>' . s:SID() . '_ScaffoldCommand_get_underscore_theme_file')
  let scaffoldCommandObj.open_file = function('<SNR>' . s:SID() . '_ScaffoldCommand_open_file')
  let scaffoldCommandObj.get_file_open_mode = function('<SNR>' . s:SID() . '_ScaffoldCommand_get_file_open_mode')
  let scaffoldCommandObj.find_scaffold_file = function('<SNR>' . s:SID() . '_ScaffoldCommand_find_scaffold_file')
  let scaffoldCommandObj.insert_into_buffer = function('<SNR>' . s:SID() . '_ScaffoldCommand_insert_into_buffer')
  let scaffoldCommandObj.WpCliCommand_do_run = function('<SNR>' . s:SID() . '_WpCliCommand_do_run')
  let scaffoldCommandObj.WpCliCommand_do_run = function('<SNR>' . s:SID() . '_WpCliCommand_do_run')
  return scaffoldCommandObj
endfunction

function! s:ScaffoldCommand_do_run(params, opts) dict
  if len(a:params) ==# 0 || a:opts.bang
    return self.WpCliCommand_do_run(a:params, a:opts)
  endif
  let action = a:params[0]
  let file_to_open = ''
  if action ==# 'post-type' || action ==# 'taxonomy'
    let a:opts.silent_cmd = 1
    let insert_output = 1
  else
    let insert_output = 0
  endif
  let result = self.WpCliCommand_do_run(a:params, a:opts)
  if insert_output
    call self.insert_into_buffer(a:opts.line1, result)
  endif
  if action ==# 'child-theme'
    let file_to_open = self.find_scaffold_file(result, 'style.css')
  elseif action ==# 'plugin'
    let plugin_name = a:params[1]
    let file_to_open = self.find_scaffold_file(result, plugin_name . ".php")
  elseif action ==# '_s'
    let theme_name = a:params[1]
    let file_to_open = self.get_underscore_theme_file(theme_name)
  endif
  if file_to_open !=# ''
    call self.open_file(file_to_open)
  endif
  return result
endfunction

function! s:ScaffoldCommand_get_underscore_theme_file(theme_name) dict
  let project = self.current_project()
  let wordpress_path = project.get_wordpress_path()
  let theme_path = wordpress_path . "/wp-content/themes/" . a:theme_name . "/style.css"
  return theme_path
endfunction

function! s:ScaffoldCommand_open_file(path) dict
  if !(filereadable(a:path))
    return 0
  endif
  let file_opener = self.lookup('file_opener')
  call file_opener.open(a:path, self.get_file_open_mode())
  return 1
endfunction

function! s:ScaffoldCommand_get_file_open_mode() dict
  if &hidden
    return 'edit'
  else
    return 'tabedit'
  endif
endfunction

function! s:ScaffoldCommand_find_scaffold_file(result, file_name) dict
  let lines = split(a:result, "\n")
  let text = lines[0]
  let pattern = "\\v^.*Success:.*Created (.*)$"
  let matches = matchlist(text, pattern)
  if len(matches) ># 0
    let theme_dir = matches[1]
    let file = theme_dir . "/" . a:file_name
    let file = fnamemodify(file, ':.')
  else
    let file = ''
  endif
  return file
endfunction

function! s:ScaffoldCommand_insert_into_buffer(line_num, text) dict
  execute ":" . a:line_num . "put=a:text"
endfunction

" included: 'shell_command.riml'
function! s:ShellCommandConstructor(container)
  let shellCommandObj = {}
  let wpCliCommandObj = s:WpCliCommandConstructor(a:container)
  call extend(shellCommandObj, wpCliCommandObj)
  let shellCommandObj.is_shell_command = 1
  let shellCommandObj.do_run = function('<SNR>' . s:SID() . '_ShellCommand_do_run')
  let shellCommandObj.get_shell_cmd = function('<SNR>' . s:SID() . '_ShellCommand_get_shell_cmd')
  let shellCommandObj.run_shell = function('<SNR>' . s:SID() . '_ShellCommand_run_shell')
  let shellCommandObj.WpCliCommand_do_run = function('<SNR>' . s:SID() . '_WpCliCommand_do_run')
  return shellCommandObj
endfunction

function! s:ShellCommand_do_run(params, opts) dict
  if a:opts.bang
    return self.WpCliCommand_do_run(a:params, a:opts)
  else
    let with_dir = self.get_with_dir()
    let cmd = self.get_shell_cmd(a:params)
    return with_dir.run(self, 'run_shell', [cmd])
  endif
endfunction

function! s:ShellCommand_get_shell_cmd(params) dict
  return "wp shell " . join(a:params, ' ')
endfunction

function! s:ShellCommand_run_shell(cmd) dict
  execute "!" . a:cmd
endfunction

" included: 'wpcli_missing_command.riml'
function! s:WpCliMissingCommandConstructor(container)
  let wpCliMissingCommandObj = {}
  let wordPressCommandObj = s:WordPressCommandConstructor(a:container)
  call extend(wpCliMissingCommandObj, wordPressCommandObj)
  let wpCliMissingCommandObj.is_wpcli_command = 1
  let wpCliMissingCommandObj.is_wpcli_missing_command = 1
  let wpCliMissingCommandObj.get_auto_register = function('<SNR>' . s:SID() . '_WpCliMissingCommand_get_auto_register')
  let wpCliMissingCommandObj.has_ex_mode = function('<SNR>' . s:SID() . '_WpCliMissingCommand_has_ex_mode')
  let wpCliMissingCommandObj.get_nargs = function('<SNR>' . s:SID() . '_WpCliMissingCommand_get_nargs')
  let wpCliMissingCommandObj.get_bang = function('<SNR>' . s:SID() . '_WpCliMissingCommand_get_bang')
  let wpCliMissingCommandObj.get_completer = function('<SNR>' . s:SID() . '_WpCliMissingCommand_get_completer')
  let wpCliMissingCommandObj.get_name = function('<SNR>' . s:SID() . '_WpCliMissingCommand_get_name')
  let wpCliMissingCommandObj.get_aliases = function('<SNR>' . s:SID() . '_WpCliMissingCommand_get_aliases')
  let wpCliMissingCommandObj.complete = function('<SNR>' . s:SID() . '_WpCliMissingCommand_complete')
  let wpCliMissingCommandObj.run = function('<SNR>' . s:SID() . '_WpCliMissingCommand_run')
  let wpCliMissingCommandObj.set_cmd_name = function('<SNR>' . s:SID() . '_WpCliMissingCommand_set_cmd_name')
  let wpCliMissingCommandObj.get_cmd_name = function('<SNR>' . s:SID() . '_WpCliMissingCommand_get_cmd_name')
  return wpCliMissingCommandObj
endfunction

function! s:WpCliMissingCommand_get_auto_register() dict
  return 0
endfunction

function! s:WpCliMissingCommand_has_ex_mode() dict
  return 1
endfunction

function! s:WpCliMissingCommand_get_nargs() dict
  return '*'
endfunction

function! s:WpCliMissingCommand_get_bang() dict
  return 1
endfunction

function! s:WpCliMissingCommand_get_completer() dict
  return 'customlist'
endfunction

function! s:WpCliMissingCommand_get_name() dict
  return 'Wmissing'
endfunction

function! s:WpCliMissingCommand_get_aliases() dict
  let aliases = []
  call add(aliases, 'Wcache')
  call add(aliases, 'Wcap')
  call add(aliases, 'Wcli')
  call add(aliases, 'Wcomment')
  call add(aliases, 'Wcore')
  call add(aliases, 'Wdb')
  call add(aliases, 'Weval')
  call add(aliases, 'Wevalfile')
  call add(aliases, 'Wexport')
  call add(aliases, 'Whelp')
  call add(aliases, 'Wimport')
  call add(aliases, 'Wjetpack')
  call add(aliases, 'Wmedia')
  call add(aliases, 'Wmenu')
  call add(aliases, 'Wnetwork')
  call add(aliases, 'Woption')
  call add(aliases, 'Wplugin')
  call add(aliases, 'Wpost')
  call add(aliases, 'Wrewrite')
  call add(aliases, 'Wrole')
  call add(aliases, 'Wscaffold')
  call add(aliases, 'Wsearchreplace')
  call add(aliases, 'Wshell')
  call add(aliases, 'Wsidebar')
  call add(aliases, 'Wsite')
  call add(aliases, 'Wsuperadmin')
  call add(aliases, 'Wterm')
  call add(aliases, 'Wtheme')
  call add(aliases, 'Wtransient')
  call add(aliases, 'Wuser')
  call add(aliases, 'Wwidget')
  return aliases
endfunction

function! s:WpCliMissingCommand_complete(word, cmd_line, cursor) dict
  return []
endfunction

function! s:WpCliMissingCommand_run(...) dict
  call s:echo_error("WP-CLI not found, or not a WordPress Directory: " . getcwd())
  return 1
endfunction

function! s:WpCliMissingCommand_set_cmd_name(name) dict
endfunction

function! s:WpCliMissingCommand_get_cmd_name() dict
  return 'missing'
endfunction

function! s:WpCliCommandFactoryConstructor()
  let wpCliCommandFactoryObj = {}
  let wpCliCommandFactoryObj.build = function('<SNR>' . s:SID() . '_WpCliCommandFactory_build')
  let wpCliCommandFactoryObj.command_for = function('<SNR>' . s:SID() . '_WpCliCommandFactory_command_for')
  return wpCliCommandFactoryObj
endfunction

function! s:WpCliCommandFactory_build(cmd_name) dict
  let cmd = self.command_for(a:cmd_name)
  if cmd.is_wpcli_command
    call cmd.set_cmd_name(a:cmd_name)
  endif
  return cmd
endfunction

function! s:WpCliCommandFactory_command_for(cmd_name) dict
  if a:cmd_name ==# 'eval-file'
    let cmd = s:EvalFileCommandConstructor(self.container)
  elseif a:cmd_name ==# 'eval'
    let cmd = s:EvalCommandConstructor(self.container)
  elseif a:cmd_name ==# 'post'
    let cmd = s:PostCommandConstructor(self.container)
  elseif a:cmd_name ==# 'scaffold'
    let cmd = s:ScaffoldCommandConstructor(self.container)
  elseif a:cmd_name ==# 'shell'
    let cmd = s:ShellCommandConstructor(self.container)
  elseif a:cmd_name ==# 'missing'
    let cmd = s:WpCliMissingCommandConstructor(self.container)
  else
    let cmd = s:WpCliCommandConstructor(self.container)
  endif
  return cmd
endfunction

function! s:ProjectConstructor()
  let projectObj = {}
  let projectObj.is_project = 1
  let projectObj.cli_exists = 0
  let projectObj.wordpress_project_path = ''
  let projectObj.commands = []
  let projectObj.on_inject = function('<SNR>' . s:SID() . '_Project_on_inject')
  let projectObj.lookup = function('<SNR>' . s:SID() . '_Project_lookup')
  let projectObj.load = function('<SNR>' . s:SID() . '_Project_load')
  let projectObj.get_root = function('<SNR>' . s:SID() . '_Project_get_root')
  let projectObj.get_wpcli_commands = function('<SNR>' . s:SID() . '_Project_get_wpcli_commands')
  let projectObj.get_commands = function('<SNR>' . s:SID() . '_Project_get_commands')
  let projectObj.load_commands = function('<SNR>' . s:SID() . '_Project_load_commands')
  let projectObj.has_cli = function('<SNR>' . s:SID() . '_Project_has_cli')
  let projectObj.get_wordpress_path = function('<SNR>' . s:SID() . '_Project_get_wordpress_path')
  let projectObj.has_wordpress_path = function('<SNR>' . s:SID() . '_Project_has_wordpress_path')
  let projectObj.destroy = function('<SNR>' . s:SID() . '_Project_destroy')
  let projectObj.load_wpcli = function('<SNR>' . s:SID() . '_Project_load_wpcli')
  let projectObj.load_wordpress_path = function('<SNR>' . s:SID() . '_Project_load_wordpress_path')
  let projectObj.load_ctags_builder = function('<SNR>' . s:SID() . '_Project_load_ctags_builder')
  let projectObj.get_wpcli = function('<SNR>' . s:SID() . '_Project_get_wpcli')
  return projectObj
endfunction

function! s:Project_on_inject() dict
  let self.container = self.container.child()
  call self.container.register('wpcli_command_factory', 'WpCliCommandFactory', 1)
  call self.container.register('project_registry', 'CommandRegistry', 1)
  call self.container.register('wpcli', 'WpCli', 1)
  call self.container.register('wpcli_path', 'WpCliPath', 1)
  call self.container.register('wpcli_config', 'WpCliConfig', 1)
  call self.container.register('wpcli_completer', 'WpCliCompleter', 1)
  call self.container.register('wpcli_printer', 'WpCliPrinter', 1)
  call self.container.register('wpcli_runner', 'WpCliRunner', 1)
  call self.container.register('wordpress_path', 'WordPressPath', 1)
  call self.container.register('post', 'Post', 1)
  call self.container.register('post_saver', 'PostSaver', 0)
  call self.container.register('leet_convertor', 'LeetConvertor', 1)
  call self.container.register('ctags_builder', 'CTagsBuilder', 1)
  call self.container.register('ctags_command_builder', 'CTagsCommandBuilder', 1)
endfunction

function! s:Project_lookup(key) dict
  return self.container.lookup(a:key)
endfunction

function! s:Project_load(root) dict
  let self.root = a:root
  call self.load_wpcli(a:root)
  call self.load_wordpress_path(a:root)
  call self.load_ctags_builder(a:root)
  if self.has_cli()
    let self.commands = self.get_wpcli_commands()
    let result = 1
  else
    call add(self.commands, 'missing')
    let result = 0
  endif
  call self.load_commands()
  return result
endfunction

function! s:Project_get_root() dict
  return self.root
endfunction

function! s:Project_get_wpcli_commands() dict
  let cmds = self.get_wpcli().list()
  if len(cmds) ==# 0
    call add(cmds, 'missing')
  endif
  return cmds
endfunction

function! s:Project_get_commands() dict
  return self.commands
endfunction

function! s:Project_load_commands() dict
  let factory = self.lookup('wpcli_command_factory')
  let registry = self.lookup('project_registry')
  for command_name in self.commands
    let cmd = factory.build(command_name)
    if cmd.is_wpcli_command
      call registry.add(cmd)
      let didAdd = 1
    endif
  endfor
endfunction

function! s:Project_has_cli() dict
  return self.cli_exists
endfunction

function! s:Project_get_wordpress_path() dict
  return self.wordpress_project_path
endfunction

function! s:Project_has_wordpress_path() dict
  return isdirectory(self.get_wordpress_path())
endfunction

function! s:Project_destroy() dict
endfunction

function! s:Project_load_wpcli(root) dict
  let cli_path = self.lookup('wpcli_path')
  let self.cli_exists = cli_path.exists(a:root)
  if self.cli_exists
    let cli = self.get_wpcli()
    call cli.set_path(cli_path.get_path(a:root))
  endif
endfunction

function! s:Project_load_wordpress_path(root) dict
  let wordpress_path = self.lookup('wordpress_path')
  let self.wordpress_project_path = wordpress_path.get_path(a:root)
endfunction

function! s:Project_load_ctags_builder(root) dict
  if self.has_wordpress_path()
    let ctags_builder = self.lookup('ctags_builder')
    call ctags_builder.set_project_path(self.get_wordpress_path())
  endif
endfunction

function! s:Project_get_wpcli() dict
  return self.lookup('wpcli')
endfunction

function! s:ProjectCollectionConstructor()
  let projectCollectionObj = {}
  let projectCollectionObj.is_project_collection = 1
  let projectCollectionObj.projects = {}
  let projectCollectionObj.needs = function('<SNR>' . s:SID() . '_ProjectCollection_needs')
  let projectCollectionObj.lookup = function('<SNR>' . s:SID() . '_ProjectCollection_lookup')
  let projectCollectionObj.size = function('<SNR>' . s:SID() . '_ProjectCollection_size')
  let projectCollectionObj.add = function('<SNR>' . s:SID() . '_ProjectCollection_add')
  let projectCollectionObj.remove = function('<SNR>' . s:SID() . '_ProjectCollection_remove')
  let projectCollectionObj.contains = function('<SNR>' . s:SID() . '_ProjectCollection_contains')
  let projectCollectionObj.project_for = function('<SNR>' . s:SID() . '_ProjectCollection_project_for')
  let projectCollectionObj.clear = function('<SNR>' . s:SID() . '_ProjectCollection_clear')
  return projectCollectionObj
endfunction

function! s:ProjectCollection_needs() dict
  return ['project']
endfunction

function! s:ProjectCollection_lookup(key) dict
  return self.container.lookup(a:key)
endfunction

function! s:ProjectCollection_size() dict
  return len(self.projects)
endfunction

function! s:ProjectCollection_add(project_path) dict
  if !(self.contains(a:project_path))
    let project = self.lookup('project')
    call project.load(a:project_path)
    let self.projects[a:project_path] = project
  endif
  return self.project_for(a:project_path)
endfunction

function! s:ProjectCollection_remove(project_path) dict
  if self.contains(a:project_path)
    unlet self.projects[a:project_path]
  endif
endfunction

function! s:ProjectCollection_contains(project_path) dict
  return has_key(self.projects, a:project_path)
endfunction

function! s:ProjectCollection_project_for(project_path) dict
  return self.projects[a:project_path]
endfunction

function! s:ProjectCollection_clear() dict
  for project in values(self.projects)
    call project.destroy()
  endfor
  let self.projects = {}
endfunction

" included: 'container.riml'
function! s:ContainerConstructor(parent)
  let containerObj = {}
  let containerObj.is_container = 1
  let containerObj.parent = a:parent
  let containerObj.objects = {}
  let containerObj.register = function('<SNR>' . s:SID() . '_Container_register')
  let containerObj.unregister = function('<SNR>' . s:SID() . '_Container_unregister')
  let containerObj.lookup = function('<SNR>' . s:SID() . '_Container_lookup')
  let containerObj.has = function('<SNR>' . s:SID() . '_Container_has')
  let containerObj.has_parent = function('<SNR>' . s:SID() . '_Container_has_parent')
  let containerObj.inject = function('<SNR>' . s:SID() . '_Container_inject')
  let containerObj.child = function('<SNR>' . s:SID() . '_Container_child')
  let containerObj.get_parent = function('<SNR>' . s:SID() . '_Container_get_parent')
  return containerObj
endfunction

function! s:Container_register(name, classname, ...) dict
  if len(a:000) ==# 0
    let singleton = 0
  else
    let singleton = a:000[0]
  endif
  if type(a:classname) ==# type('')
    let object = s:ContainerObjectConstructor(a:classname, singleton)
  else
    let object = s:ContainerObjectConstructor('ExistingObject', 1)
    call object.set_instance(a:classname)
  endif
  let self.objects[a:name] = object
endfunction

function! s:Container_unregister(name, from_parent) dict
  if has_key(self.objects, a:name)
    unlet self.objects[a:name]
  endif
  if a:from_parent && self.has_parent()
    call self.parent.unregister(a:name, a:from_parent)
  endif
endfunction

function! s:Container_lookup(name) dict
  if has_key(self.objects, a:name)
    let object = self.objects[a:name]
    let instance = object.get_instance()
    call self.inject(instance)
    return instance
  elseif self.has_parent()
    return self.parent.lookup(a:name)
  else
    throw "Container object not found: " . a:name
  endif
endfunction

function! s:Container_has(name) dict
  return has_key(self.objects, a:name) || (self.has_parent() && self.parent.has(a:name))
endfunction

function! s:Container_has_parent() dict
  return has_key(self.parent, 'is_container')
endfunction

function! s:Container_inject(instance) dict
  if type(a:instance) !=# type({}) || has_key(a:instance, 'container')
    return
  endif
  if has_key(a:instance, 'needs')
    let needs = a:instance.needs()
    for need in needs
      let dependency = self.lookup(need)
      let a:instance[need] = dependency
    endfor
  endif
  let a:instance['container'] = self
  if has_key(a:instance, 'on_inject')
    call a:instance.on_inject()
  endif
endfunction

function! s:Container_child() dict
  return s:ContainerConstructor(self)
endfunction

function! s:Container_get_parent() dict
  return self.parent
endfunction

function! s:ContainerObjectConstructor(classname, singleton)
  let containerObjectObj = {}
  let containerObjectObj.classname = a:classname
  let containerObjectObj.singleton = a:singleton
  let containerObjectObj.is_container_object = 1
  let containerObjectObj.get_instance = function('<SNR>' . s:SID() . '_ContainerObject_get_instance')
  let containerObjectObj.set_instance = function('<SNR>' . s:SID() . '_ContainerObject_set_instance')
  let containerObjectObj.instantiated = function('<SNR>' . s:SID() . '_ContainerObject_instantiated')
  let containerObjectObj.needs_new_instance = function('<SNR>' . s:SID() . '_ContainerObject_needs_new_instance')
  let containerObjectObj.create = function('<SNR>' . s:SID() . '_ContainerObject_create')
  return containerObjectObj
endfunction

function! s:ContainerObject_get_instance() dict
  if self.needs_new_instance()
    let Klass = function("s:" . self.classname . "Constructor")
    let self.instance_object = self.create(Klass)
  endif
  return self.instance_object
endfunction

function! s:ContainerObject_set_instance(instance) dict
  let self.instance_object = a:instance
endfunction

function! s:ContainerObject_instantiated() dict
  return has_key(self, 'instance_object')
endfunction

function! s:ContainerObject_needs_new_instance() dict
  return !self.instantiated() || !self.singleton
endfunction

function! s:ContainerObject_create(Klass) dict
  return a:Klass()
endfunction

" included: 'configure_buffer_command.riml'
function! s:ConfigureBufferCommandConstructor(container)
  let configureBufferCommandObj = {}
  let wordPressCommandObj = s:WordPressCommandConstructor(a:container)
  call extend(configureBufferCommandObj, wordPressCommandObj)
  let configureBufferCommandObj.get_name = function('<SNR>' . s:SID() . '_ConfigureBufferCommand_get_name')
  let configureBufferCommandObj.run = function('<SNR>' . s:SID() . '_ConfigureBufferCommand_run')
  return configureBufferCommandObj
endfunction

function! s:ConfigureBufferCommand_get_name() dict
  return 'ConfigureBuffer'
endfunction

function! s:ConfigureBufferCommand_run(buffer, opts) dict
  let buffer_collection = self.lookup('buffer_collection')
  call buffer_collection.add(a:buffer)
endfunction

" included: 'change_current_buffer_command.riml'
function! s:ChangeCurrentBufferCommandConstructor(container)
  let changeCurrentBufferCommandObj = {}
  let wordPressCommandObj = s:WordPressCommandConstructor(a:container)
  call extend(changeCurrentBufferCommandObj, wordPressCommandObj)
  let changeCurrentBufferCommandObj.get_name = function('<SNR>' . s:SID() . '_ChangeCurrentBufferCommand_get_name')
  let changeCurrentBufferCommandObj.run = function('<SNR>' . s:SID() . '_ChangeCurrentBufferCommand_run')
  return changeCurrentBufferCommandObj
endfunction

function! s:ChangeCurrentBufferCommand_get_name() dict
  return 'ChangeCurrentBuffer'
endfunction

function! s:ChangeCurrentBufferCommand_run(buffer, opts) dict
  let buffer_collection = self.lookup('buffer_collection')
  let project_collection = self.lookup('project_collection')
  let project_path = a:buffer.get_project_path()
  let project_added = 0
  call buffer_collection.set_current(a:buffer)
  if !(project_collection.contains(project_path))
    let project = project_collection.add(project_path)
    let project_added = 1
  endif
  if project_collection.contains(project_path)
    call self.process('LoadProjectRegistry')
    call self.process('LoadSyntax')
    call self.process('Wctags')
  endif
endfunction

" included: 'load_syntax_command.riml'
function! s:LoadSyntaxCommandConstructor(container)
  let loadSyntaxCommandObj = {}
  let wordPressCommandObj = s:WordPressCommandConstructor(a:container)
  call extend(loadSyntaxCommandObj, wordPressCommandObj)
  let loadSyntaxCommandObj.get_name = function('<SNR>' . s:SID() . '_LoadSyntaxCommand_get_name')
  let loadSyntaxCommandObj.run = function('<SNR>' . s:SID() . '_LoadSyntaxCommand_run')
  let loadSyntaxCommandObj.is_php_buffer = function('<SNR>' . s:SID() . '_LoadSyntaxCommand_is_php_buffer')
  let loadSyntaxCommandObj.is_readme_buffer = function('<SNR>' . s:SID() . '_LoadSyntaxCommand_is_readme_buffer')
  let loadSyntaxCommandObj.load_php_syntax = function('<SNR>' . s:SID() . '_LoadSyntaxCommand_load_php_syntax')
  let loadSyntaxCommandObj.load_readme_syntax = function('<SNR>' . s:SID() . '_LoadSyntaxCommand_load_readme_syntax')
  let loadSyntaxCommandObj.load_readme_auto_validator = function('<SNR>' . s:SID() . '_LoadSyntaxCommand_load_readme_auto_validator')
  let loadSyntaxCommandObj.needs_readme_auto_validator = function('<SNR>' . s:SID() . '_LoadSyntaxCommand_needs_readme_auto_validator')
  return loadSyntaxCommandObj
endfunction

function! s:LoadSyntaxCommand_get_name() dict
  return 'LoadSyntax'
endfunction

function! s:LoadSyntaxCommand_run(opts) dict
  if self.is_php_buffer()
    call self.load_php_syntax()
  elseif self.is_readme_buffer()
    call self.load_readme_syntax()
  endif
endfunction

function! s:LoadSyntaxCommand_is_php_buffer() dict
  return &filetype ==# 'php'
endfunction

function! s:LoadSyntaxCommand_is_readme_buffer() dict
  return self.current_buffer_full_path() =~# 'readme.txt'
endfunction

function! s:LoadSyntaxCommand_load_php_syntax() dict
  set filetype=php.wordpress
endfunction

function! s:LoadSyntaxCommand_load_readme_syntax() dict
  set filetype=markdown.readme
  call self.load_readme_auto_validator()
endfunction

function! s:LoadSyntaxCommand_load_readme_auto_validator() dict
  if self.needs_readme_auto_validator()
    call self.process('ReadmeAutoValidator')
  endif
endfunction

function! s:LoadSyntaxCommand_needs_readme_auto_validator() dict
  if exists('g:wordpress_vim_readme_auto_validator')
    return g:wordpress_vim_readme_auto_validator
  else
    return 1
  endif
endfunction

" included: 'load_project_registry_command.riml'
function! s:LoadProjectRegistryCommandConstructor(container)
  let loadProjectRegistryCommandObj = {}
  let wordPressProjectCommandObj = s:WordPressProjectCommandConstructor(a:container)
  call extend(loadProjectRegistryCommandObj, wordPressProjectCommandObj)
  let loadProjectRegistryCommandObj.get_name = function('<SNR>' . s:SID() . '_LoadProjectRegistryCommand_get_name')
  let loadProjectRegistryCommandObj.run = function('<SNR>' . s:SID() . '_LoadProjectRegistryCommand_run')
  return loadProjectRegistryCommandObj
endfunction

function! s:LoadProjectRegistryCommand_get_name() dict
  return 'LoadProjectRegistry'
endfunction

function! s:LoadProjectRegistryCommand_run(opts) dict
  let registry = self.lookup('registry')
  call registry.register_commands()
  let project_registry = self.lookup('project_registry')
  call project_registry.register_commands()
  call self.process('LoadMappings')
endfunction

" included: 'configure_tags_command.riml'
function! s:ConfigureTagsCommandConstructor(container)
  let configureTagsCommandObj = {}
  let wordPressProjectCommandObj = s:WordPressProjectCommandConstructor(a:container)
  call extend(configureTagsCommandObj, wordPressProjectCommandObj)
  let configureTagsCommandObj.is_configure_tags_command = 1
  let configureTagsCommandObj.get_name = function('<SNR>' . s:SID() . '_ConfigureTagsCommand_get_name')
  let configureTagsCommandObj.has_ex_mode = function('<SNR>' . s:SID() . '_ConfigureTagsCommand_has_ex_mode')
  let configureTagsCommandObj.run = function('<SNR>' . s:SID() . '_ConfigureTagsCommand_run')
  let configureTagsCommandObj.generate_ctags = function('<SNR>' . s:SID() . '_ConfigureTagsCommand_generate_ctags')
  let configureTagsCommandObj.regenerate_ctags = function('<SNR>' . s:SID() . '_ConfigureTagsCommand_regenerate_ctags')
  let configureTagsCommandObj.needs_tags_generation = function('<SNR>' . s:SID() . '_ConfigureTagsCommand_needs_tags_generation')
  let configureTagsCommandObj.configure_tag_option = function('<SNR>' . s:SID() . '_ConfigureTagsCommand_configure_tag_option')
  return configureTagsCommandObj
endfunction

function! s:ConfigureTagsCommand_get_name() dict
  return 'Wctags'
endfunction

function! s:ConfigureTagsCommand_has_ex_mode() dict
  return 1
endfunction

function! s:ConfigureTagsCommand_run(opts) dict
  let buffer = self.current_buffer()
  let project = self.current_project()
  if has_key(a:opts, 'bang') && a:opts.bang
    call self.regenerate_ctags()
  elseif project.has_wordpress_path()
    let didGenerate = self.generate_ctags()
    if didGenerate
      call s:echo_msg('WordPress: Generating ctags ... DONE')
    endif
  endif
  call self.configure_tag_option()
endfunction

function! s:ConfigureTagsCommand_generate_ctags(...) dict
  let __splat_var_cpy = copy(a:000)
  if !empty(__splat_var_cpy)
    let msg = remove(__splat_var_cpy, 0)
  else
    let msg = 'Generating'
  endif
  let ctags_builder = self.lookup('ctags_builder')
  if ctags_builder.get_project_path() ==# ''
    call s:echo_error('Could not generate tags, WordPress not detected, Please set g:wordpress_vim_wordpress_path in your vimrc')
    return 0
  endif
  if self.needs_tags_generation()
    if !exists('g:wordpress_vim_dont_generate_tags') || !g:wordpress_vim_dont_generate_tags
      call s:echo_msg("WordPress: " . msg . " ctags ...")
      call ctags_builder.generate()
      return 1
    endif
  endif
  return 0
endfunction

function! s:ConfigureTagsCommand_regenerate_ctags() dict
  let ctags_builder = self.lookup('ctags_builder')
  if !(ctags_builder.has_executable())
    call s:echo_error("Exuberant Ctags was not found.")
    return
  endif
  let tags_path = ctags_builder.get_project_tags()
  if filereadable(tags_path)
    call delete(tags_path)
  endif
  let didGenerate = self.generate_ctags('Regenerating')
  if didGenerate
    call s:echo_msg('WordPress: Regenerating ctags DONE')
  endif
endfunction

function! s:ConfigureTagsCommand_needs_tags_generation() dict
  let ctags_builder = self.lookup('ctags_builder')
  return !ctags_builder.has_tags() && ctags_builder.has_executable()
endfunction

function! s:ConfigureTagsCommand_configure_tag_option() dict
  let ctags_builder = self.lookup('ctags_builder')
  let tags_option = self.lookup('tags_option')
  if ctags_builder.has_tags()
    let tags_path = fnamemodify(ctags_builder.get_project_tags(), ':p')
    if !(tags_option.get_tags() =~# tags_path)
      call tags_option.prepend(tags_path)
    endif
  endif
endfunction

" included: 'codex_search_command.riml'
function! s:CodexSearchCommandConstructor(container)
  let codexSearchCommandObj = {}
  let wordPressCommandObj = s:WordPressCommandConstructor(a:container)
  call extend(codexSearchCommandObj, wordPressCommandObj)
  let codexSearchCommandObj.is_codex_search_command = 1
  let codexSearchCommandObj.get_name = function('<SNR>' . s:SID() . '_CodexSearchCommand_get_name')
  let codexSearchCommandObj.get_bang = function('<SNR>' . s:SID() . '_CodexSearchCommand_get_bang')
  let codexSearchCommandObj.get_auto_register = function('<SNR>' . s:SID() . '_CodexSearchCommand_get_auto_register')
  let codexSearchCommandObj.get_range = function('<SNR>' . s:SID() . '_CodexSearchCommand_get_range')
  let codexSearchCommandObj.has_ex_mode = function('<SNR>' . s:SID() . '_CodexSearchCommand_has_ex_mode')
  let codexSearchCommandObj.run = function('<SNR>' . s:SID() . '_CodexSearchCommand_run')
  let codexSearchCommandObj.get_codex_query = function('<SNR>' . s:SID() . '_CodexSearchCommand_get_codex_query')
  let codexSearchCommandObj.has_open_browser = function('<SNR>' . s:SID() . '_CodexSearchCommand_has_open_browser')
  let codexSearchCommandObj.urlencode = function('<SNR>' . s:SID() . '_CodexSearchCommand_urlencode')
  return codexSearchCommandObj
endfunction

function! s:CodexSearchCommand_get_name() dict
  return 'Wcodexsearch'
endfunction

function! s:CodexSearchCommand_get_bang() dict
  return 0
endfunction

function! s:CodexSearchCommand_get_auto_register() dict
  return 1
endfunction

function! s:CodexSearchCommand_get_range() dict
  return 1
endfunction

function! s:CodexSearchCommand_has_ex_mode() dict
  return 1
endfunction

function! s:CodexSearchCommand_run(...) dict
  let [params, opts] = self.expand_args(a:000)
  let current_word = self.get_current_word(params, opts)
  if self.has_open_browser()
    let search_query = self.get_codex_query(current_word)
    execute ":OpenBrowser " . search_query
  else
    call s:echo_error("Error: OpenBrowser.vim plugin was not found.")
  endif
endfunction

function! s:CodexSearchCommand_get_codex_query(query) dict
  return "http://wordpress.org/search/" . a:query
endfunction

function! s:CodexSearchCommand_has_open_browser() dict
  return exists(':OpenBrowser') ==# 2
endfunction

function! s:CodexSearchCommand_urlencode(query) dict
  if has('python')
    return execute ":python import urllib; print urllib.quote_plus('" . a:query . "')"
  else
    return a:query
  endif
endfunction

" included: 'goto_definition_command.riml'
" included: 'tag_list_matcher.riml'
" included: 'tag_match.riml'
function! s:TagMatchConstructor(keyword, status, ...)
  let __splat_var_cpy = copy(a:000)
  if !empty(__splat_var_cpy)
    let position = remove(__splat_var_cpy, 0)
  else
    let position = 0
  endif
  let tagMatchObj = {}
  let tagMatchObj.keyword = a:keyword
  let tagMatchObj.status = a:status
  let tagMatchObj.position = position
  let tagMatchObj.get_keyword = function('<SNR>' . s:SID() . '_TagMatch_get_keyword')
  let tagMatchObj.is_match = function('<SNR>' . s:SID() . '_TagMatch_is_match')
  let tagMatchObj.get_position = function('<SNR>' . s:SID() . '_TagMatch_get_position')
  return tagMatchObj
endfunction

function! s:TagMatch_get_keyword() dict
  return self.keyword
endfunction

function! s:TagMatch_is_match() dict
  return self.status
endfunction

function! s:TagMatch_get_position() dict
  return self.position
endfunction

function! s:TagListMatcherConstructor()
  let tagListMatcherObj = {}
  let tagListMatcherObj.match = function('<SNR>' . s:SID() . '_TagListMatcher_match')
  let tagListMatcherObj.get_taglist = function('<SNR>' . s:SID() . '_TagListMatcher_get_taglist')
  let tagListMatcherObj.is_function = function('<SNR>' . s:SID() . '_TagListMatcher_is_function')
  let tagListMatcherObj.is_stub_function = function('<SNR>' . s:SID() . '_TagListMatcher_is_stub_function')
  let tagListMatcherObj.is_variable = function('<SNR>' . s:SID() . '_TagListMatcher_is_variable')
  return tagListMatcherObj
endfunction

function! s:TagListMatcher_match(keyword) dict
  let matches = self.get_taglist(a:keyword)
  let total_matches = len(matches)
  if total_matches ># 0
    let index = -1
    for match in matches
      let index = index + 1
      if !(has_key(match, 'cmd'))
        continue
      endif
      let pattern = match.cmd
      if self.is_variable(a:keyword, pattern)
        continue
      endif
      if self.is_stub_function(a:keyword, pattern)
        continue
      endif
      return s:TagMatchConstructor(a:keyword, 1, index)
    endfor
  else
    return s:TagMatchConstructor(a:keyword, 0, 0)
  endif
endfunction

function! s:TagListMatcher_get_taglist(keyword) dict
  if has_key(self, 'mock_taglist')
    return self.mock_taglist
  endif
  return taglist(a:keyword)
endfunction

function! s:TagListMatcher_is_function(keyword, pattern) dict
  if self.is_variable(a:keyword, a:pattern)
    return 0
  endif
  if self.is_stub_function(a:keyword, a:pattern)
    return 0
  endif
  return a:pattern =~# "function " . a:keyword
endfunction

function! s:TagListMatcher_is_stub_function(keyword, pattern) dict
  return a:pattern =~# '{}'
endfunction

function! s:TagListMatcher_is_variable(keyword, pattern) dict
  return a:pattern =~# "$" . a:keyword
endfunction

function! s:GotoDefinitionCommandConstructor(container)
  let gotoDefinitionCommandObj = {}
  let wordPressProjectCommandObj = s:WordPressProjectCommandConstructor(a:container)
  call extend(gotoDefinitionCommandObj, wordPressProjectCommandObj)
  let gotoDefinitionCommandObj.get_name = function('<SNR>' . s:SID() . '_GotoDefinitionCommand_get_name')
  let gotoDefinitionCommandObj.has_ex_mode = function('<SNR>' . s:SID() . '_GotoDefinitionCommand_has_ex_mode')
  let gotoDefinitionCommandObj.get_auto_register = function('<SNR>' . s:SID() . '_GotoDefinitionCommand_get_auto_register')
  let gotoDefinitionCommandObj.get_range = function('<SNR>' . s:SID() . '_GotoDefinitionCommand_get_range')
  let gotoDefinitionCommandObj.run = function('<SNR>' . s:SID() . '_GotoDefinitionCommand_run')
  let gotoDefinitionCommandObj.jump_to = function('<SNR>' . s:SID() . '_GotoDefinitionCommand_jump_to')
  let gotoDefinitionCommandObj.jump_to_hook = function('<SNR>' . s:SID() . '_GotoDefinitionCommand_jump_to_hook')
  let gotoDefinitionCommandObj.to_hook_command = function('<SNR>' . s:SID() . '_GotoDefinitionCommand_to_hook_command')
  let gotoDefinitionCommandObj.get_jump_cmd = function('<SNR>' . s:SID() . '_GotoDefinitionCommand_get_jump_cmd')
  let gotoDefinitionCommandObj.to_display_word = function('<SNR>' . s:SID() . '_GotoDefinitionCommand_to_display_word')
  let gotoDefinitionCommandObj.strip_prefix = function('<SNR>' . s:SID() . '_GotoDefinitionCommand_strip_prefix')
  return gotoDefinitionCommandObj
endfunction

function! s:GotoDefinitionCommand_get_name() dict
  return 'Wdef'
endfunction

function! s:GotoDefinitionCommand_has_ex_mode() dict
  return 1
endfunction

function! s:GotoDefinitionCommand_get_auto_register() dict
  return 0
endfunction

function! s:GotoDefinitionCommand_get_range() dict
  return 1
endfunction

function! s:GotoDefinitionCommand_run(...) dict
  let [params, opts] = self.expand_args(a:000)
  let current_word = self.get_current_word(params, opts)
  let current_line = self.get_current_line()
  let hook_matcher = self.lookup('hook_matcher')
  let hook_match = hook_matcher.match(current_line, current_word)
  if hook_match.is_match()
    return self.jump_to_hook(hook_match)
  endif
  let tag_list_matcher = self.lookup('tag_list_matcher')
  let found = tag_list_matcher.match(current_word)
  if found.is_match()
    let position = found.get_position()
    let cmd = self.get_jump_cmd(current_word, position)
    let success = self.jump_to(cmd)
  else
    let success = 0
  endif
  if !(success)
    let display_word = self.to_display_word(current_word)
    call s:echo_error("No match for: " . display_word)
  endif
endfunction

function! s:GotoDefinitionCommand_jump_to(cmd) dict
  try
    execute a:cmd
    return 1
  catch
    return 0
  endtry
endfunction

function! s:GotoDefinitionCommand_jump_to_hook(hook_match) dict
  let cmd = self.to_hook_command(a:hook_match.get_kind())
  if has_key(cmd, 'name')
    let opts = {'bang': cmd.bang, 'is_option': 1}
    call self.process(cmd.name, a:hook_match.get_keyword(), opts)
  endif
endfunction

function! s:GotoDefinitionCommand_to_hook_command(kind) dict
  if a:kind ==# 'action'
    let cmd = {'name': 'Waction', 'bang': 0}
  elseif a:kind ==# 'alistener'
    let cmd = {'name': 'Waction', 'bang': 1}
  elseif a:kind ==# 'filter'
    let cmd = {'name': 'Wfilter', 'bang': 0}
  elseif a:kind ==# 'flistener'
    let cmd = {'name': 'Wfilter', 'bang': 1}
  else
    let cmd = {}
  endif
  return cmd
endfunction

function! s:GotoDefinitionCommand_get_jump_cmd(keyword, position) dict
  if a:position !=# 0
    let position = a:position + 1
    return ":" . position . "tag " . a:keyword
  else
    return ":tag " . a:keyword
  endif
endfunction

function! s:GotoDefinitionCommand_to_display_word(word) dict
  let builder = self.lookup('ctags_command_builder')
  let display_word = a:word
  let display_word = self.strip_prefix(display_word, builder.get_action_uid())
  let display_word = self.strip_prefix(display_word, builder.get_action_listener_uid())
  let display_word = self.strip_prefix(display_word, builder.get_filter_uid())
  let display_word = self.strip_prefix(display_word, builder.get_filter_listener_uid())
  return display_word
endfunction

function! s:GotoDefinitionCommand_strip_prefix(word, prefix) dict
  return substitute(a:word, "^" . a:prefix . "_", '', '')
endfunction

" included: 'load_mappings_command.riml'
function! s:LoadMappingsCommandConstructor(container)
  let loadMappingsCommandObj = {}
  let wordPressProjectCommandObj = s:WordPressProjectCommandConstructor(a:container)
  call extend(loadMappingsCommandObj, wordPressProjectCommandObj)
  let loadMappingsCommandObj.get_name = function('<SNR>' . s:SID() . '_LoadMappingsCommand_get_name')
  let loadMappingsCommandObj.run = function('<SNR>' . s:SID() . '_LoadMappingsCommand_run')
  let loadMappingsCommandObj.needs_jump_mappings = function('<SNR>' . s:SID() . '_LoadMappingsCommand_needs_jump_mappings')
  let loadMappingsCommandObj.load_jump_mappings = function('<SNR>' . s:SID() . '_LoadMappingsCommand_load_jump_mappings')
  let loadMappingsCommandObj.get_def_delegate = function('<SNR>' . s:SID() . '_LoadMappingsCommand_get_def_delegate')
  let loadMappingsCommandObj.jump_to_def = function('<SNR>' . s:SID() . '_LoadMappingsCommand_jump_to_def')
  return loadMappingsCommandObj
endfunction

function! s:LoadMappingsCommand_get_name() dict
  return 'LoadMappings'
endfunction

function! s:LoadMappingsCommand_run(opts) dict
  if self.needs_jump_mappings()
    call self.load_jump_mappings()
  endif
endfunction

function! s:LoadMappingsCommand_needs_jump_mappings() dict
  if exists('g:wordpress_vim_jump_to_core_mappings')
    return g:wordpress_vim_jump_to_core_mappings
  else
    return 1
  endif
endfunction

function! s:LoadMappingsCommand_load_jump_mappings() dict
  let DefDelegate = self.get_def_delegate()
  execute ":nnoremap <buffer> <c-]> :call " . DefDelegate . "(0)<cr>"
  execute ":vnoremap <buffer> <c-]> :call " . DefDelegate . "(0)<cr>"
  execute ":nnoremap <buffer> <c-w>] :call " . DefDelegate . "(1)<cr>"
  execute ":vnoremap <buffer> <c-w>] :call " . DefDelegate . "(1)<cr>"
endfunction

function! s:LoadMappingsCommand_get_def_delegate() dict
  if !(has_key(self, 'DefDelegate'))
    let self.DefDelegate = s:new_delegate(self, 'jump_to_def')
  endif
  return self.DefDelegate
endfunction

function! s:LoadMappingsCommand_jump_to_def(split_buffer) dict
  if (a:split_buffer)
    sp
  endif
  call self.process('Wdef')
endfunction

" included: 'similar_functions_command.riml'
function! s:SimilarFunctionsCommandConstructor(container)
  let similarFunctionsCommandObj = {}
  let wordPressProjectCommandObj = s:WordPressProjectCommandConstructor(a:container)
  call extend(similarFunctionsCommandObj, wordPressProjectCommandObj)
  let similarFunctionsCommandObj.is_similar_command = 1
  let similarFunctionsCommandObj.get_name = function('<SNR>' . s:SID() . '_SimilarFunctionsCommand_get_name')
  let similarFunctionsCommandObj.get_auto_register = function('<SNR>' . s:SID() . '_SimilarFunctionsCommand_get_auto_register')
  let similarFunctionsCommandObj.has_ex_mode = function('<SNR>' . s:SID() . '_SimilarFunctionsCommand_has_ex_mode')
  let similarFunctionsCommandObj.get_range = function('<SNR>' . s:SID() . '_SimilarFunctionsCommand_get_range')
  let similarFunctionsCommandObj.run = function('<SNR>' . s:SID() . '_SimilarFunctionsCommand_run')
  return similarFunctionsCommandObj
endfunction

function! s:SimilarFunctionsCommand_get_name() dict
  return 'Wsimilar'
endfunction

function! s:SimilarFunctionsCommand_get_auto_register() dict
  return 0
endfunction

function! s:SimilarFunctionsCommand_has_ex_mode() dict
  return 1
endfunction

function! s:SimilarFunctionsCommand_get_range() dict
  return 1
endfunction

function! s:SimilarFunctionsCommand_run(...) dict
  let [params, opts] = self.expand_args(a:000)
  let prompter = self.lookup('choice_prompter')
  let current_word = self.get_current_word(params, opts)
  let wpseek_api = self.lookup('wpseek_api')
  call s:echo_msg("Looking for Functions similar to '" . current_word . "' ...")
  let functions = wpseek_api.find_similar(current_word, 10)
  if self.is_false(functions) || len(functions) ==# 0
    call s:echo_msg("No results found for: '" . current_word . "'")
    return
  endif
  let choice_id = prompter.prompt_for(functions)
  if !(choice_id ==# -1)
    let choice = functions[choice_id - 1]
    call self.process('Wdef', choice)
  endif
endfunction

" included: 'similar_topics_command.riml'
function! s:SimilarTopicsCommandConstructor(container)
  let similarTopicsCommandObj = {}
  let wordPressProjectCommandObj = s:WordPressProjectCommandConstructor(a:container)
  call extend(similarTopicsCommandObj, wordPressProjectCommandObj)
  let similarTopicsCommandObj.is_similar_topics_command = 1
  let similarTopicsCommandObj.get_name = function('<SNR>' . s:SID() . '_SimilarTopicsCommand_get_name')
  let similarTopicsCommandObj.get_auto_register = function('<SNR>' . s:SID() . '_SimilarTopicsCommand_get_auto_register')
  let similarTopicsCommandObj.has_ex_mode = function('<SNR>' . s:SID() . '_SimilarTopicsCommand_has_ex_mode')
  let similarTopicsCommandObj.get_range = function('<SNR>' . s:SID() . '_SimilarTopicsCommand_get_range')
  let similarTopicsCommandObj.run = function('<SNR>' . s:SID() . '_SimilarTopicsCommand_run')
  let similarTopicsCommandObj.to_topic_labels = function('<SNR>' . s:SID() . '_SimilarTopicsCommand_to_topic_labels')
  return similarTopicsCommandObj
endfunction

function! s:SimilarTopicsCommand_get_name() dict
  return 'Wtopics'
endfunction

function! s:SimilarTopicsCommand_get_auto_register() dict
  return 0
endfunction

function! s:SimilarTopicsCommand_has_ex_mode() dict
  return 1
endfunction

function! s:SimilarTopicsCommand_get_range() dict
  return 1
endfunction

function! s:SimilarTopicsCommand_run(...) dict
  let [params, opts] = self.expand_args(a:000)
  let prompter = self.lookup('choice_prompter')
  let current_word = self.get_current_word(params, opts)
  let wpseek_api = self.lookup('wpseek_api')
  call s:echo_msg("Searching wordpress.org for Topic: '" . current_word . "' ...")
  let topics = wpseek_api.find_topics(current_word, 10)
  if self.is_false(topics) || len(topics) ==# 0
    call s:echo_msg("No topics found for: '" . current_word . "'")
    return
  endif
  let topic_labels = self.to_topic_labels(topics)
  let topic_id = prompter.prompt_for(topic_labels)
  if !(topic_id ==# -1)
    let topic = topics[topic_id - 1]
    let topic_url = topic.link
    execute ":OpenBrowser " . topic_url
  endif
endfunction

function! s:SimilarTopicsCommand_to_topic_labels(topics) dict
  let topic_labels = []
  for topic in a:topics
    call add(topic_labels, topic.title)
  endfor
  return topic_labels
endfunction

" included: 'wp_action_command.riml'
" included: 'wp_hook_command.riml'
function! s:WpHookCommandConstructor(container)
  let wpHookCommandObj = {}
  let wordPressProjectCommandObj = s:WordPressProjectCommandConstructor(a:container)
  call extend(wpHookCommandObj, wordPressProjectCommandObj)
  let wpHookCommandObj.is_wp_hook_command = 1
  let wpHookCommandObj.get_auto_register = function('<SNR>' . s:SID() . '_WpHookCommand_get_auto_register')
  let wpHookCommandObj.has_ex_mode = function('<SNR>' . s:SID() . '_WpHookCommand_has_ex_mode')
  let wpHookCommandObj.get_completer = function('<SNR>' . s:SID() . '_WpHookCommand_get_completer')
  let wpHookCommandObj.has_ctrlp_mode = function('<SNR>' . s:SID() . '_WpHookCommand_has_ctrlp_mode')
  let wpHookCommandObj.get_count = function('<SNR>' . s:SID() . '_WpHookCommand_get_count')
  let wpHookCommandObj.cmd_line_has_bang = function('<SNR>' . s:SID() . '_WpHookCommand_cmd_line_has_bang')
  let wpHookCommandObj.remove_uid_prefix = function('<SNR>' . s:SID() . '_WpHookCommand_remove_uid_prefix')
  let wpHookCommandObj.add_uid_prefix = function('<SNR>' . s:SID() . '_WpHookCommand_add_uid_prefix')
  let wpHookCommandObj.filter_hooks = function('<SNR>' . s:SID() . '_WpHookCommand_filter_hooks')
  let wpHookCommandObj.get_tags_for_uid = function('<SNR>' . s:SID() . '_WpHookCommand_get_tags_for_uid')
  let wpHookCommandObj.get_hooks_for = function('<SNR>' . s:SID() . '_WpHookCommand_get_hooks_for')
  let wpHookCommandObj.get_ctag_kind = function('<SNR>' . s:SID() . '_WpHookCommand_get_ctag_kind')
  let wpHookCommandObj.get_kind_uid = function('<SNR>' . s:SID() . '_WpHookCommand_get_kind_uid')
  let wpHookCommandObj.complete = function('<SNR>' . s:SID() . '_WpHookCommand_complete')
  let wpHookCommandObj.run = function('<SNR>' . s:SID() . '_WpHookCommand_run')
  return wpHookCommandObj
endfunction

function! s:WpHookCommand_get_auto_register() dict
  return 0
endfunction

function! s:WpHookCommand_has_ex_mode() dict
  return 1
endfunction

function! s:WpHookCommand_get_completer() dict
  return 'customlist'
endfunction

function! s:WpHookCommand_has_ctrlp_mode() dict
  return 1
endfunction

function! s:WpHookCommand_get_count() dict
  return 1
endfunction

function! s:WpHookCommand_cmd_line_has_bang(cmd_line) dict
  return a:cmd_line =~# '!'
endfunction

function! s:WpHookCommand_remove_uid_prefix(text, uid) dict
  return substitute(a:text, a:uid . "_", '', '')
endfunction

function! s:WpHookCommand_add_uid_prefix(text, uid) dict
  return a:uid . "_" . a:text
endfunction

function! s:WpHookCommand_filter_hooks(hooks, start) dict
  return filter(a:hooks, "v:val =~ '^" . a:start . "'")
endfunction

function! s:WpHookCommand_get_tags_for_uid(uid) dict
  if has_key(self, 'mock_tags_for_uid')
    return self.mock_tags_for_uid
  endif
  return taglist(a:uid)
endfunction

function! s:WpHookCommand_get_hooks_for(uid) dict
  let tags = self.get_tags_for_uid(a:uid)
  let hooks = []
  let hooks_added = {}
  for tag in tags
    if has_key(tag, 'name') && !has_key(hooks_added, tag.name)
      let hook = self.remove_uid_prefix(tag.name, a:uid)
      let hooks_added[tag.name] = 1
      call add(hooks, hook)
    endif
  endfor
  return hooks
endfunction

function! s:WpHookCommand_get_ctag_kind(bang) dict
  return 'action'
endfunction

function! s:WpHookCommand_get_kind_uid(kind) dict
  let ctags_command_builder = self.lookup('ctags_command_builder')
  return ctags_command_builder.to_leet(a:kind)
endfunction

function! s:WpHookCommand_complete(word, cmd_line, cursor) dict
  let bang = self.cmd_line_has_bang(a:cmd_line)
  let kind = self.get_ctag_kind(bang)
  let uid = self.get_kind_uid(kind)
  let hooks = self.get_hooks_for(uid)
  let filtered = self.filter_hooks(hooks, a:word)
  return filtered
endfunction

function! s:WpHookCommand_run(...) dict
  let [params, opts] = self.expand_args(a:000)
  if len(params) ==# 0
    let param = self.get_current_word(params, opts)
  else
    let param = params[0]
  endif
  let bang = has_key(opts, 'bang') && opts.bang
  let kind = self.get_ctag_kind(bang)
  let uid = self.get_kind_uid(kind)
  let definition = self.add_uid_prefix(param, uid)
  call self.process('Wdef', definition)
endfunction

function! s:WpActionCommandConstructor(container)
  let wpActionCommandObj = {}
  let wpHookCommandObj = s:WpHookCommandConstructor(a:container)
  call extend(wpActionCommandObj, wpHookCommandObj)
  let wpActionCommandObj.get_name = function('<SNR>' . s:SID() . '_WpActionCommand_get_name')
  let wpActionCommandObj.get_ctrlp_names = function('<SNR>' . s:SID() . '_WpActionCommand_get_ctrlp_names')
  let wpActionCommandObj.get_ctag_kind = function('<SNR>' . s:SID() . '_WpActionCommand_get_ctag_kind')
  return wpActionCommandObj
endfunction

function! s:WpActionCommand_get_name() dict
  return 'Waction'
endfunction

function! s:WpActionCommand_get_ctrlp_names() dict
  return ['action']
endfunction

function! s:WpActionCommand_get_ctag_kind(bang) dict
  if a:bang
    return 'action'
  else
    return 'alistener'
  endif
endfunction

" included: 'wp_filter_command.riml'
function! s:WpFilterCommandConstructor(container)
  let wpFilterCommandObj = {}
  let wpHookCommandObj = s:WpHookCommandConstructor(a:container)
  call extend(wpFilterCommandObj, wpHookCommandObj)
  let wpFilterCommandObj.get_name = function('<SNR>' . s:SID() . '_WpFilterCommand_get_name')
  let wpFilterCommandObj.get_ctrlp_names = function('<SNR>' . s:SID() . '_WpFilterCommand_get_ctrlp_names')
  let wpFilterCommandObj.get_ctag_kind = function('<SNR>' . s:SID() . '_WpFilterCommand_get_ctag_kind')
  return wpFilterCommandObj
endfunction

function! s:WpFilterCommand_get_name() dict
  return 'Wfilter'
endfunction

function! s:WpFilterCommand_get_ctrlp_names() dict
  return ['filter']
endfunction

function! s:WpFilterCommand_get_ctag_kind(bang) dict
  if a:bang
    return 'filter'
  else
    return 'flistener'
  endif
endfunction

" included: 'validate_readme_command.riml'
function! s:ValidateReadmeCommandConstructor(container)
  let validateReadmeCommandObj = {}
  let wordPressProjectCommandObj = s:WordPressProjectCommandConstructor(a:container)
  call extend(validateReadmeCommandObj, wordPressProjectCommandObj)
  let validateReadmeCommandObj.is_validate_readme_command = 1
  let validateReadmeCommandObj.get_name = function('<SNR>' . s:SID() . '_ValidateReadmeCommand_get_name')
  let validateReadmeCommandObj.get_auto_register = function('<SNR>' . s:SID() . '_ValidateReadmeCommand_get_auto_register')
  let validateReadmeCommandObj.has_ex_mode = function('<SNR>' . s:SID() . '_ValidateReadmeCommand_has_ex_mode')
  let validateReadmeCommandObj.get_nargs = function('<SNR>' . s:SID() . '_ValidateReadmeCommand_get_nargs')
  let validateReadmeCommandObj.run = function('<SNR>' . s:SID() . '_ValidateReadmeCommand_run')
  let validateReadmeCommandObj.get_project_readme = function('<SNR>' . s:SID() . '_ValidateReadmeCommand_get_project_readme')
  let validateReadmeCommandObj.display_list = function('<SNR>' . s:SID() . '_ValidateReadmeCommand_display_list')
  return validateReadmeCommandObj
endfunction

function! s:ValidateReadmeCommand_get_name() dict
  return 'Wreadme'
endfunction

function! s:ValidateReadmeCommand_get_auto_register() dict
  return 0
endfunction

function! s:ValidateReadmeCommand_has_ex_mode() dict
  return 1
endfunction

function! s:ValidateReadmeCommand_get_nargs() dict
  return '?'
endfunction

function! s:ValidateReadmeCommand_run(...) dict
  let [params, opts] = self.expand_args(a:000)
  if len(params) ==# 1
    let readme = params[0]
  elseif &filetype ==# 'text'
    let readme = self.current_buffer_full_path()
  else
    let readme = self.get_project_readme()
  endif
  let short_readme = fnamemodify(readme, ':.')
  if !(filereadable(readme))
    call s:echo_msg("Readme not found: " . short_readme)
    return
  endif
  call s:echo_msg("Validating " . short_readme . " ...")
  let readme_full_path = fnamemodify(readme, ':p')
  let validator = self.lookup('readme_validator')
  let result = validator.validate(readme_full_path)
  if !(result.is_readme_validation_result)
    return
  endif
  if result.status ==# 'success'
    call s:echo_msg(result.value)
  elseif result.status ==# 'errors'
    call self.display_list('Error', result.value)
  elseif result.status ==# 'notes'
    call self.display_list('Note', result.value)
  endif
endfunction

function! s:ValidateReadmeCommand_get_project_readme() dict
  return self.current_buffer_project_path() . "/readme.txt"
endfunction

function! s:ValidateReadmeCommand_display_list(label, list) dict
  let i = 1
  for item in a:list
    let msg = a:label . " " . '#' . i . ": " . item
    call s:echo_msg(msg)
    let i += 1
  endfor
endfunction

" included: 'readme_auto_validator_command.riml'
function! s:ReadmeAutoValidatorCommandConstructor(container)
  let readmeAutoValidatorCommandObj = {}
  let wordPressProjectCommandObj = s:WordPressProjectCommandConstructor(a:container)
  call extend(readmeAutoValidatorCommandObj, wordPressProjectCommandObj)
  let readmeAutoValidatorCommandObj.is_readme_auto_validator_command = 1
  let readmeAutoValidatorCommandObj.get_name = function('<SNR>' . s:SID() . '_ReadmeAutoValidatorCommand_get_name')
  let readmeAutoValidatorCommandObj.get_auto_register = function('<SNR>' . s:SID() . '_ReadmeAutoValidatorCommand_get_auto_register')
  let readmeAutoValidatorCommandObj.has_ex_mode = function('<SNR>' . s:SID() . '_ReadmeAutoValidatorCommand_has_ex_mode')
  let readmeAutoValidatorCommandObj.run = function('<SNR>' . s:SID() . '_ReadmeAutoValidatorCommand_run')
  let readmeAutoValidatorCommandObj.before_file_save = function('<SNR>' . s:SID() . '_ReadmeAutoValidatorCommand_before_file_save')
  let readmeAutoValidatorCommandObj.after_file_save = function('<SNR>' . s:SID() . '_ReadmeAutoValidatorCommand_after_file_save')
  return readmeAutoValidatorCommandObj
endfunction

function! s:ReadmeAutoValidatorCommand_get_name() dict
  return 'ReadmeAutoValidator'
endfunction

function! s:ReadmeAutoValidatorCommand_get_auto_register() dict
  return 0
endfunction

function! s:ReadmeAutoValidatorCommand_has_ex_mode() dict
  return 0
endfunction

function! s:ReadmeAutoValidatorCommand_run(opts) dict
  let path = self.current_buffer_full_path()
  let loader = s:AutocmdLoaderConstructor()
  call loader.set_group_name('wordpress_vim_readme_auto_validator')
  call loader.cmd("BufWritePre " . path . " call " . s:new_delegate(self, 'before_file_save') . "()")
  call loader.cmd("BufWritePost " . path . " call " . s:new_delegate(self, 'after_file_save') . "()")
  call loader.load()
endfunction

function! s:ReadmeAutoValidatorCommand_before_file_save() dict
  let self.modified = &mod
endfunction

function! s:ReadmeAutoValidatorCommand_after_file_save() dict
  if !(self.modified)
    return
  endif
  call self.process('Wreadme')
endfunction

function! s:ControllerConstructor()
  let controllerObj = {}
  let controllerObj.container = s:ContainerConstructor({})
  let controllerObj.process = function('<SNR>' . s:SID() . '_Controller_process')
  let controllerObj.load = function('<SNR>' . s:SID() . '_Controller_load')
  let controllerObj.configure_container = function('<SNR>' . s:SID() . '_Controller_configure_container')
  let controllerObj.load_commands = function('<SNR>' . s:SID() . '_Controller_load_commands')
  let controllerObj.lookup = function('<SNR>' . s:SID() . '_Controller_lookup')
  return controllerObj
endfunction

function! s:Controller_process(...) dict
  let registry = self.container.lookup('registry')
  return call(registry['run_action'], a:000, registry)
endfunction

function! s:Controller_load() dict
  call self.configure_container()
  call self.load_commands()
endfunction

function! s:Controller_configure_container() dict
  let c = self.container
  call c.register('registry', 'CommandRegistry', 1)
  call c.register('buffer_collection', 'BufferCollection', 1)
  call c.register('project_collection', 'ProjectCollection', 1)
  call c.register('project', 'Project', 0)
  call c.register('with_dir', 'WithDir', 0)
  call c.register('file_opener', 'FileOpener', 0)
  call c.register('tags_option', 'TagsOption', 1)
  call c.register('tag_list_matcher', 'TagListMatcher', 1)
  call c.register('choice_prompter', 'ChoicePrompter', 1)
  call c.register('wpseek_api', 'WpSeekApi', 1)
  call c.register('hook_match', 'HookMatch', 0)
  call c.register('hook_matcher', 'HookMatcher', 1)
  call c.register('readme_validator', 'ReadmeValidator', 1)
endfunction

function! s:Controller_load_commands() dict
  let c = self.container
  let r = c.lookup('registry')
  call r.add(s:ConfigureBufferCommandConstructor(c))
  call r.add(s:ChangeCurrentBufferCommandConstructor(c))
  call r.add(s:LoadSyntaxCommandConstructor(c))
  call r.add(s:LoadProjectRegistryCommandConstructor(c))
  call r.add(s:ConfigureTagsCommandConstructor(c))
  call r.add(s:CodexSearchCommandConstructor(c))
  call r.add(s:GotoDefinitionCommandConstructor(c))
  call r.add(s:LoadMappingsCommandConstructor(c))
  call r.add(s:SimilarFunctionsCommandConstructor(c))
  call r.add(s:SimilarTopicsCommandConstructor(c))
  call r.add(s:WpActionCommandConstructor(c))
  call r.add(s:WpFilterCommandConstructor(c))
  call r.add(s:ValidateReadmeCommandConstructor(c))
  call r.add(s:ReadmeAutoValidatorCommandConstructor(c))
endfunction

function! s:Controller_lookup(key) dict
  return self.container.lookup(a:key)
endfunction

function! s:AppConstructor()
  let appObj = {}
  let appObj.controller = s:ControllerConstructor()
  let appObj.start = function('<SNR>' . s:SID() . '_App_start')
  let appObj.on_buffer_open = function('<SNR>' . s:SID() . '_App_on_buffer_open')
  let appObj.on_buffer_enter = function('<SNR>' . s:SID() . '_App_on_buffer_enter')
  let appObj.on_buffer_leave = function('<SNR>' . s:SID() . '_App_on_buffer_leave')
  return appObj
endfunction

function! s:App_start() dict
  call self.controller.load()
endfunction

function! s:App_on_buffer_open(buffer) dict
  return self.controller.process('ConfigureBuffer', a:buffer)
endfunction

function! s:App_on_buffer_enter(buffer) dict
  return self.controller.process('ChangeCurrentBuffer', a:buffer)
endfunction

function! s:App_on_buffer_leave(buffer) dict
endfunction

let g:wordpress_vim_path = expand('<sfile>:h:h')
function! wordpress#app()
  if !(exists('s:app'))
    let s:app = s:AppConstructor()
    call s:app.start()
    let g:wordpress_vim_loaded = 1
  endif
  return s:app
endfunction
